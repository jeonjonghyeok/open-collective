"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformTest = void 0;
const di_1 = require("@tsed/di");
const platform_builder_1 = require("../../platform-builder");
const PlatformContext_1 = require("../../platform/domain/PlatformContext");
const PlatformApplication_1 = require("../../platform/services/PlatformApplication");
const PlatformRequest_1 = require("../../platform/services/PlatformRequest");
const PlatformResponse_1 = require("../../platform/services/PlatformResponse");
/**
 * @platform
 */
class PlatformTest extends di_1.DITest {
    static async create(options = {}) {
        di_1.DITest.injector = PlatformTest.createInjector(options);
        await platform_builder_1.loadInjector(di_1.DITest.injector);
    }
    /**
     * Create a new injector with the right default services
     */
    static createInjector(settings = {}) {
        return platform_builder_1.createInjector(di_1.DITest.configure(settings));
    }
    /**
     * Load the server silently without listening port and configure it on test profile.
     * @decorator
     * @param mod
     * @param options
     * @returns {Promise<void>}
     */
    static bootstrap(mod, settings = {}) {
        return async function before() {
            let instance;
            const platform = settings.platform || PlatformTest.platformBuilder;
            /* istanbul ignore next */
            if (!platform) {
                throw new Error("Platform type is not specified. Have you added at least `import @tsed/platform-express` (or equivalent) on your Server.ts ?");
            }
            // @ts-ignore
            instance = await platform_builder_1.PlatformBuilder.build(platform).bootstrap(mod, di_1.DITest.configure(settings));
            await instance.callHook("$beforeListen");
            await instance.callHook("$afterListen");
            await instance.ready();
            // used by inject method
            di_1.DITest.injector = instance.injector;
        };
    }
    /**
     * It injects services into the test function where you can alter, spy on, and manipulate them.
     *
     * The inject function has two parameters
     *
     * * an array of Service dependency injection tokens,
     * * a test function whose parameters correspond exactly to each item in the injection token array.
     *
     * @param targets
     * @param func
     */
    static inject(targets, func) {
        return async () => {
            if (!di_1.DITest.hasInjector()) {
                await PlatformTest.create();
            }
            const injector = di_1.DITest.injector;
            const deps = [];
            for (const target of targets) {
                deps.push(injector.has(target) ? injector.get(target) : await injector.invoke(target));
            }
            return await func(...deps);
        };
    }
    /**
     * Return the raw application (express or koa).
     * Use this callback with SuperTest.
     *
     * ```typescript
     * let request: SuperTest.SuperTest<SuperTest.Test>;
     * beforeEach(PlatformTest.bootstrap(Server, {
     *   mount: {
     *     "/rest": [ProductsController]
     *   }
     * }));
     * beforeEach(() => {
     *   request = SuperTest(PlatformTest.callback());
     * });
     * ```
     */
    static callback() {
        var _a;
        return (_a = di_1.DITest.injector.get(PlatformApplication_1.PlatformApplication)) === null || _a === void 0 ? void 0 : _a.callback();
    }
    static createRequestContext(options = {}) {
        options.request = options.request || new PlatformRequest_1.PlatformRequest({});
        options.response = options.response || new PlatformResponse_1.PlatformResponse({});
        return new PlatformContext_1.PlatformContext({
            id: "id",
            injector: di_1.DITest.injector,
            logger: di_1.DITest.injector.logger,
            url: "/",
            ...options
        });
    }
}
exports.PlatformTest = PlatformTest;
//# sourceMappingURL=PlatformTest.js.map