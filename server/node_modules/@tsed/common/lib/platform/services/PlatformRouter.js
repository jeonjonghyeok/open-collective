"use strict";
var PlatformRouter_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformRouter = exports.PLATFORM_ROUTER_OPTIONS = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@tsed/di");
const util_1 = require("util");
const FakeRawDriver_1 = require("./FakeRawDriver");
const PlatformHandler_1 = require("./PlatformHandler");
/**
 * @ignore
 */
exports.PLATFORM_ROUTER_OPTIONS = Symbol.for("PlatformRouterOptions");
/**
 * Platform Router abstraction layer.
 * @platform
 */
let PlatformRouter = PlatformRouter_1 = class PlatformRouter {
    constructor(platformHandler) {
        this.platformHandler = platformHandler;
        this.rawRouter = this.raw = PlatformRouter_1.createRawRouter();
    }
    /**
     * Create a new instance of PlatformRouter
     * @param injector
     * @param routerOptions
     */
    static create(injector, routerOptions = {}) {
        const locals = new Map();
        locals.set(exports.PLATFORM_ROUTER_OPTIONS, routerOptions);
        return injector.invoke(PlatformRouter_1, locals);
    }
    static createRawRouter() {
        return FakeRawDriver_1.createFakeRawDriver();
    }
    callback() {
        return this.raw;
    }
    getRouter() {
        return this.rawRouter;
    }
    use(...handlers) {
        // @ts-ignore
        this.getRouter().use(...this.mapHandlers(handlers));
        return this;
    }
    addRoute(options) {
        const { method, path, handlers, isFinal } = options;
        // @ts-ignore
        this.getRouter()[method](path, ...this.mapHandlers(handlers, { method, path, isFinal }));
        return this;
    }
    all(path, ...handlers) {
        return this.addRoute({ method: "all", path, handlers, isFinal: true });
    }
    get(path, ...handlers) {
        return this.addRoute({ method: "get", path, handlers, isFinal: true });
    }
    post(path, ...handlers) {
        return this.addRoute({ method: "post", path, handlers, isFinal: true });
    }
    put(path, ...handlers) {
        return this.addRoute({ method: "put", path, handlers, isFinal: true });
    }
    delete(path, ...handlers) {
        return this.addRoute({ method: "delete", path, handlers, isFinal: true });
    }
    patch(path, ...handlers) {
        return this.addRoute({ method: "patch", path, handlers, isFinal: true });
    }
    head(path, ...handlers) {
        return this.addRoute({ method: "head", path, handlers, isFinal: true });
    }
    options(path, ...handlers) {
        return this.addRoute({ method: "options", path, handlers, isFinal: true });
    }
    statics(path, options) {
        return this;
    }
    multer(options) {
        const m = require("multer")(options);
        const makePromise = (multer, name) => {
            // istanbul ignore next
            if (!multer[name])
                return;
            const fn = multer[name];
            multer[name] = function apply(...args) {
                const middleware = Reflect.apply(fn, this, args);
                return (req, res) => util_1.promisify(middleware)(req, res);
            };
        };
        makePromise(m, "any");
        makePromise(m, "array");
        makePromise(m, "fields");
        makePromise(m, "none");
        makePromise(m, "single");
        return m;
    }
    mapHandlers(handlers, options = {}) {
        return handlers.reduce((list, handler, index) => {
            if (typeof handler === "string") {
                return list.concat(handler);
            }
            if (handler instanceof PlatformRouter_1) {
                return list.concat(handler.callback());
            }
            return list.concat(this.platformHandler.createHandler(handler, {
                ...options,
                isFinal: options.isFinal ? index === handlers.length - 1 : false
            }));
        }, []);
    }
};
tslib_1.__decorate([
    di_1.Inject(),
    tslib_1.__metadata("design:type", di_1.InjectorService)
], PlatformRouter.prototype, "injector", void 0);
PlatformRouter = PlatformRouter_1 = tslib_1.__decorate([
    di_1.Injectable({
        scope: di_1.ProviderScope.INSTANCE
    }),
    tslib_1.__metadata("design:paramtypes", [PlatformHandler_1.PlatformHandler])
], PlatformRouter);
exports.PlatformRouter = PlatformRouter;
//# sourceMappingURL=PlatformRouter.js.map