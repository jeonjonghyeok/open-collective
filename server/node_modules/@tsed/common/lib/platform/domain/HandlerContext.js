"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandlerContext = exports.HandlerContextStatus = void 0;
const core_1 = require("@tsed/core");
/**
 * @ignore
 */
function isResponse(obj) {
    return obj.data && obj.headers && obj.status && obj.statusText;
}
/**
 * @ignore
 */
var HandlerContextStatus;
(function (HandlerContextStatus) {
    HandlerContextStatus["PENDING"] = "pending";
    HandlerContextStatus["CANCELED"] = "canceled";
    HandlerContextStatus["RESOLVED"] = "resolved";
    HandlerContextStatus["REJECTED"] = "rejected";
})(HandlerContextStatus = exports.HandlerContextStatus || (exports.HandlerContextStatus = {}));
class HandlerContext {
    constructor({ $ctx, err, metadata, args }) {
        this.status = HandlerContextStatus.PENDING;
        this.promise = new Promise((resolve, reject) => {
            this.resolves = resolve;
            this.rejects = reject;
        });
        this.$ctx = $ctx;
        err && (this.err = err);
        metadata && (this.metadata = metadata);
        args && (this.args = args || []);
        this.next = this.next.bind(this);
    }
    get injector() {
        var _a;
        return (_a = this.$ctx) === null || _a === void 0 ? void 0 : _a.injector;
    }
    get container() {
        var _a;
        return (_a = this.$ctx) === null || _a === void 0 ? void 0 : _a.container;
    }
    get request() {
        var _a;
        return (_a = this.$ctx) === null || _a === void 0 ? void 0 : _a.getRequest();
    }
    get response() {
        var _a;
        return (_a = this.$ctx) === null || _a === void 0 ? void 0 : _a.getResponse();
    }
    get isDone() {
        const { $ctx } = this;
        if (!$ctx || $ctx.isDone()) {
            return true;
        }
        if ($ctx.request.isAborted() || $ctx.response.isDone()) {
            this.destroy();
            if (this.status === HandlerContextStatus.PENDING) {
                this.status = HandlerContextStatus.RESOLVED;
            }
        }
        return this.status !== HandlerContextStatus.PENDING;
    }
    /**
     * Return the original request instance.
     */
    getRequest() {
        var _a, _b;
        return (_b = (_a = this.$ctx) === null || _a === void 0 ? void 0 : _a.request) === null || _b === void 0 ? void 0 : _b.raw;
    }
    /**
     * Return the original response instance.
     */
    getResponse() {
        var _a, _b;
        return (_b = (_a = this.$ctx) === null || _a === void 0 ? void 0 : _a.response) === null || _b === void 0 ? void 0 : _b.raw;
    }
    /**
     *
     */
    async callHandler() {
        if (this.isDone) {
            return this;
        }
        const { token, propertyKey } = this.metadata;
        const instance = this.injector.invoke(token, this.container);
        const handler = instance[propertyKey].bind(instance);
        try {
            this.handle(handler(...this.args));
        }
        catch (er) {
            this.reject(er);
        }
        return this.promise;
    }
    reject(er) {
        if (this.isDone) {
            return;
        }
        this.destroy();
        this.status = HandlerContextStatus.REJECTED;
        this.rejects(er);
    }
    resolve(data) {
        if (this.isDone) {
            return;
        }
        if (this.$ctx && data !== undefined) {
            this.$ctx.data = data;
        }
        this.destroy();
        this.status = HandlerContextStatus.RESOLVED;
        this.resolves(data);
    }
    next(error) {
        if (this.isDone) {
            return;
        }
        return error ? this.reject(error) : this.resolve();
    }
    destroy() {
        // @ts-ignore
        delete this.$ctx;
        // @ts-ignore
        delete this.args;
        // @ts-ignore
        delete this.metadata;
        // @ts-ignore
        delete this.err;
    }
    cancel() {
        if (this.isDone) {
            return;
        }
        this.destroy();
        this.status = HandlerContextStatus.CANCELED;
        return this.resolves();
    }
    handle(process) {
        if (this.isDone) {
            return;
        }
        const { metadata: { hasNextFunction }, $ctx } = this;
        if (process) {
            if (process === $ctx.getResponse()) {
                // ABANDON
                return this.cancel();
            }
            if (core_1.isObservable(process)) {
                process = process.toPromise();
            }
            if (isResponse(process)) {
                $ctx.response.setHeaders(process.headers);
                $ctx.response.status(process.status);
                return this.handle(process.data);
            }
            if (core_1.isStream(process) || Buffer.isBuffer(process)) {
                return this.resolve(process);
            }
            if (core_1.isPromise(process)) {
                return process.then((result) => this.handle(result)).catch((error) => this.reject(error));
            }
        }
        if (!hasNextFunction) {
            // no next function and empty response
            return this.resolve(process);
        }
    }
}
exports.HandlerContext = HandlerContext;
//# sourceMappingURL=HandlerContext.js.map