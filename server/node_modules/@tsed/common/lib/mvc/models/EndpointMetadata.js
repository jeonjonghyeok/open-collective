"use strict";
var EndpointMetadata_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.EndpointMetadata = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const schema_1 = require("@tsed/schema");
/**
 * EndpointMetadata contains metadata about a controller and his method.
 * Each annotation (@Get, @Body...) attached to a method are stored in a endpoint.
 * EndpointMetadata convert this metadata to an array which contain arguments to call an Express method.
 *
 * Example :
 *
 *    @Controller("/my-path")
 *    provide MyClass {
 *
 *        @Get("/")
 *        @Authenticated()
 *        public myMethod(){}
 *    }
 *
 */
let EndpointMetadata = EndpointMetadata_1 = class EndpointMetadata extends schema_1.JsonEntityStore {
    constructor(options) {
        super({
            store: core_1.Store.fromMethod(options.target, options.propertyKey),
            descriptor: core_1.descriptorOf(options.target, options.propertyKey),
            ...options
        });
        // LIFECYCLE
        this.beforeMiddlewares = [];
        this.middlewares = [];
        this.afterMiddlewares = [];
        this.statusCode = 200;
        const { beforeMiddlewares = [], middlewares = [], afterMiddlewares = [] } = options;
        this.after(afterMiddlewares);
        this.before(beforeMiddlewares);
        this.use(middlewares);
    }
    get targetName() {
        return core_1.nameOf(this.token);
    }
    get params() {
        return Array.from(this.children.values());
    }
    /**
     * Return the JsonOperation
     */
    get operation() {
        return this._operation;
    }
    get operationPaths() {
        return this.operation.operationPaths;
    }
    get view() {
        return this.store.get("view");
    }
    set view(view) {
        this.store.set("view", view);
    }
    get location() {
        return this.store.get("location");
    }
    set location(url) {
        this.store.set("location", url);
    }
    get redirect() {
        return this.store.get("redirect");
    }
    set redirect(options) {
        this.store.set("redirect", {
            status: 302,
            ...options
        });
    }
    /**
     * Get all endpoints from a given class and his parents.
     * @param {Type<any>} target
     * @returns {EndpointMetadata[]}
     */
    static getEndpoints(target) {
        const operations = schema_1.getOperationsStores(target);
        return Array.from(operations.values()).map((endpoint) => {
            endpoint = endpoint.clone();
            endpoint.token = core_1.classOf(target);
            return endpoint;
        });
    }
    /**
     * Get an endpoint.
     * @param target
     * @param propertyKey
     * @param descriptor
     */
    static get(target, propertyKey, descriptor) {
        descriptor = descriptor || core_1.descriptorOf(core_1.prototypeOf(target), propertyKey);
        return schema_1.JsonEntityStore.from(core_1.prototypeOf(target), propertyKey, descriptor);
    }
    addOperationPath(method, path, options = {}) {
        return this.operation.addOperationPath(method, path, options);
    }
    /**
     * Find the a value at the controller level. Let this value be extended or overridden by the endpoint itself.
     *
     * @param key
     * @returns {any}
     */
    get(key) {
        const ctrlValue = core_1.Store.from(this.target).get(key);
        let meta = core_1.deepExtends(undefined, ctrlValue);
        const endpointValue = this.store.get(key);
        if (endpointValue !== undefined) {
            meta = core_1.deepExtends(meta, endpointValue);
        }
        return meta;
    }
    /**
     * Append middlewares to the beforeMiddlewares list.
     * @param args
     * @returns {EndpointMetadata}
     */
    before(args) {
        this.beforeMiddlewares = this.beforeMiddlewares.concat(args).filter(core_1.isFunction);
        return this;
    }
    /**
     * Append middlewares to the afterMiddlewares list.
     * @param args
     * @returns {EndpointMetadata}
     */
    after(args) {
        this.afterMiddlewares = this.afterMiddlewares.concat(args).filter(core_1.isFunction);
        return this;
    }
    /**
     * Store all arguments collected via Annotation.
     * @param args
     */
    use(args) {
        this.middlewares = this.middlewares.concat(args).filter(core_1.isFunction);
        return this;
    }
    clone() {
        const endpoint = new EndpointMetadata_1({
            ...this,
            target: this.target,
            propertyKey: this.propertyKey,
            descriptor: this.descriptor,
            store: this.store,
            children: this.children
        });
        endpoint.collectionType = this.collectionType;
        endpoint._type = this._type;
        endpoint._operation = this.operation;
        endpoint._schema = this._schema;
        endpoint.middlewares = [...this.middlewares];
        endpoint.afterMiddlewares = [...this.afterMiddlewares];
        endpoint.beforeMiddlewares = [...this.beforeMiddlewares];
        return endpoint;
    }
};
tslib_1.__decorate([
    core_1.Enumerable(),
    tslib_1.__metadata("design:type", Array)
], EndpointMetadata.prototype, "beforeMiddlewares", void 0);
tslib_1.__decorate([
    core_1.Enumerable(),
    tslib_1.__metadata("design:type", Array)
], EndpointMetadata.prototype, "middlewares", void 0);
tslib_1.__decorate([
    core_1.Enumerable(),
    tslib_1.__metadata("design:type", Array)
], EndpointMetadata.prototype, "afterMiddlewares", void 0);
tslib_1.__decorate([
    core_1.Enumerable(),
    tslib_1.__metadata("design:type", Number)
], EndpointMetadata.prototype, "statusCode", void 0);
EndpointMetadata = EndpointMetadata_1 = tslib_1.__decorate([
    schema_1.JsonEntityComponent(core_1.DecoratorTypes.METHOD),
    tslib_1.__metadata("design:paramtypes", [Object])
], EndpointMetadata);
exports.EndpointMetadata = EndpointMetadata;
//# sourceMappingURL=EndpointMetadata.js.map