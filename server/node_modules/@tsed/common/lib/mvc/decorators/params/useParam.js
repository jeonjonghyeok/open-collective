"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UseParam = void 0;
const useType_1 = require("./useType");
const core_1 = require("@tsed/core");
const schema_1 = require("@tsed/schema");
const paramFn_1 = require("./paramFn");
const useDeserialization_1 = require("./useDeserialization");
const useParamExpression_1 = require("./useParamExpression");
const useParamType_1 = require("./useParamType");
const useValidation_1 = require("./useValidation");
/**
 * @ignore
 * @param options
 */
function mapPipes(options = {}) {
    const { paramType, useType, expression, useValidation, useConverter, ...props } = options;
    return [
        useType
            ? useType_1.UseType(useType)
            : paramFn_1.ParamFn((entity, parameters) => {
                if (entity.isCollection && entity.type === Object) {
                    schema_1.Any()(...parameters);
                }
            }),
        expression && useParamExpression_1.UseParamExpression(expression),
        expression && schema_1.Name(expression),
        useValidation && useValidation_1.UseValidation(),
        useConverter && useDeserialization_1.UseDeserialization(props)
    ];
}
/**
 * Register a new param. It use the paramType to extract value and give it to the next pipe.
 *
 * Given options allow to enable or disable following pipes:
 *
 * - useType: Add extra type for the json mapper,
 * - expression: Get property from the returned value by the previous pipe.
 * - useValidation: Apply validation from the returned value by the previous pipe.
 * - useConverter: Apply json mapper from the returned value by the previous pipe.
 *
 * @param paramType
 * @param options
 * @decorator
 * @operation
 * @input
 * @pipe
 */
function UseParam(paramType, options = {}) {
    return core_1.useDecorators(useParamType_1.UseParamType(paramType), ...mapPipes({ paramType, ...options }));
}
exports.UseParam = UseParam;
//# sourceMappingURL=useParam.js.map