{"version":3,"file":"route.js","sourceRoot":"","sources":["../../../../src/mvc/decorators/method/route.ts"],"names":[],"mappings":";;;AAAA,+BAA0B;AAE1B;;;;;;;;;;;;;;GAcG;AACH,SAAgB,GAAG,CAAC,OAA8B,GAAG,EAAE,GAAG,IAAW;IACnE,OAAO,SAAG,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;AAC5C,CAAC;AAFD,kBAEC;AAED;;;;;;;;;;;;;;GAcG;AACH,SAAgB,GAAG,CAAC,OAA8B,GAAG,EAAE,GAAG,IAAW;IACnE,OAAO,SAAG,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;AAC5C,CAAC;AAFD,kBAEC;AAED;;;;;;;;;;;;;;GAcG;AACH,SAAgB,IAAI,CAAC,OAA8B,GAAG,EAAE,GAAG,IAAW;IACpE,OAAO,SAAG,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;AAC7C,CAAC;AAFD,oBAEC;AAED;;;;;;;;;;;;;;GAcG;AACH,SAAgB,GAAG,CAAC,OAA8B,GAAG,EAAE,GAAG,IAAW;IACnE,OAAO,SAAG,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;AAC5C,CAAC;AAFD,kBAEC;AAED;;;;;;;;;;;;;;GAcG;AACH,SAAgB,MAAM,CAAC,OAA8B,GAAG,EAAE,GAAG,IAAW;IACtE,OAAO,SAAG,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;AAC/C,CAAC;AAFD,wBAEC;AAED;;;;;;;;;;;;;;GAcG;AACH,SAAgB,IAAI,CAAC,OAA8B,GAAG,EAAE,GAAG,IAAW;IACpE,OAAO,SAAG,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;AAC7C,CAAC;AAFD,oBAEC;AAED;;;;;;;;;;;;;;GAcG;AACH,SAAgB,KAAK,CAAC,OAA8B,GAAG,EAAE,GAAG,IAAW;IACrE,OAAO,SAAG,CAAC,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;AAC9C,CAAC;AAFD,sBAEC;AAED;;;;;;;;;;;;;;GAcG;AACH,SAAgB,OAAO,CAAC,OAA8B,GAAG,EAAE,GAAG,IAAW;IACvE,OAAO,SAAG,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;AAChD,CAAC;AAFD,0BAEC","sourcesContent":["import {Use} from \"./use\";\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function All(path: string | RegExp | any = \"/\", ...args: any[]): Function {\n  return Use(...[\"all\", path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function Get(path: string | RegExp | any = \"/\", ...args: any[]): Function {\n  return Use(...[\"get\", path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function Post(path: string | RegExp | any = \"/\", ...args: any[]): Function {\n  return Use(...[\"post\", path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function Put(path: string | RegExp | any = \"/\", ...args: any[]): Function {\n  return Use(...[\"put\", path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function Delete(path: string | RegExp | any = \"/\", ...args: any[]): Function {\n  return Use(...[\"delete\", path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function Head(path: string | RegExp | any = \"/\", ...args: any[]): Function {\n  return Use(...[\"head\", path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function Patch(path: string | RegExp | any = \"/\", ...args: any[]): Function {\n  return Use(...[\"patch\", path].concat(args));\n}\n\n/**\n * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).\n *\n * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.\n * For example, if you placed the following route at the top of all other route definitions, it would require that\n * all routes from that point on would require authentication, and automatically load a user.\n * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()\n * to continue matching subsequent routes.\n * @param path\n * @param args\n * @returns {Function}\n * @decorator\n * @operation\n * @httpMethod\n */\nexport function Options(path: string | RegExp | any = \"/\", ...args: any[]): Function {\n  return Use(...[\"options\", path].concat(args));\n}\n"]}