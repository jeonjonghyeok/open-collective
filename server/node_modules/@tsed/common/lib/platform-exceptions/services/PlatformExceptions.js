"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformExceptions = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
require("../components/ErrorFilter");
require("../components/ExceptionFilter");
require("../components/StringErrorFilter");
require("../components/MongooseErrorFilter");
const ExceptionFiltersContainer_1 = require("../domain/ExceptionFiltersContainer");
const ResourceNotFound_1 = require("../errors/ResourceNotFound");
/**
 * Catch all errors and return the json error with the right status code when it's possible.
 *
 * @platform
 */
let PlatformExceptions = class PlatformExceptions {
    constructor() {
        this.types = new Map();
    }
    $onInit() {
        ExceptionFiltersContainer_1.ExceptionFiltersContainer.forEach((token, type) => {
            this.types.set(type, this.injector.get(token));
        });
    }
    catch(error, ctx) {
        const name = core_1.nameOf(core_1.classOf(error));
        if (name && this.types.has(name)) {
            return this.types.get(name).catch(error, ctx);
        }
        const target = core_1.ancestorsOf(error)
            .reverse()
            .find((target) => this.types.has(target));
        if (target) {
            return this.types.get(target).catch(error, ctx);
        }
    }
    resourceNotFound(ctx) {
        return this.catch(new ResourceNotFound_1.ResourceNotFound(ctx.request.url), ctx);
    }
};
tslib_1.__decorate([
    di_1.Inject(),
    tslib_1.__metadata("design:type", di_1.InjectorService)
], PlatformExceptions.prototype, "injector", void 0);
PlatformExceptions = tslib_1.__decorate([
    di_1.Injectable()
], PlatformExceptions);
exports.PlatformExceptions = PlatformExceptions;
//# sourceMappingURL=PlatformExceptions.js.map