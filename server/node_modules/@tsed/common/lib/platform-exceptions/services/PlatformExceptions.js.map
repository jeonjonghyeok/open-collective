{"version":3,"file":"PlatformExceptions.js","sourceRoot":"","sources":["../../../src/platform-exceptions/services/PlatformExceptions.ts"],"names":[],"mappings":";;;;AAAA,qCAAwD;AACxD,iCAA6D;AAE7D,qCAAmC;AACnC,yCAAuC;AACvC,2CAAyC;AACzC,6CAA2C;AAC3C,mFAAkG;AAClG,iEAA4D;AAG5D;;;;GAIG;AAEH,IAAa,kBAAkB,GAA/B,MAAa,kBAAkB;IAA/B;QACE,UAAK,GAAoD,IAAI,GAAG,EAAE,CAAC;IA8BrE,CAAC;IAzBC,OAAO;QACL,qDAAyB,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,IAAI,EAAE,EAAE;YAChD,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAE,CAAC,CAAC;QAClD,CAAC,CAAC,CAAC;IACL,CAAC;IAED,KAAK,CAAC,KAAc,EAAE,GAAoB;QACxC,MAAM,IAAI,GAAG,aAAM,CAAC,cAAO,CAAC,KAAK,CAAC,CAAC,CAAC;QAEpC,IAAI,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YAChC,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAE,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;SAChD;QAED,MAAM,MAAM,GAAG,kBAAW,CAAC,KAAK,CAAC;aAC9B,OAAO,EAAE;aACT,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;QAE5C,IAAI,MAAM,EAAE;YACV,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAE,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;SAClD;IACH,CAAC;IAED,gBAAgB,CAAC,GAAoB;QACnC,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,mCAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;IAChE,CAAC;CACF,CAAA;AA3BC;IADC,WAAM,EAAE;sCACC,oBAAe;oDAAC;AAJf,kBAAkB;IAD9B,eAAU,EAAE;GACA,kBAAkB,CA+B9B;AA/BY,gDAAkB","sourcesContent":["import {ancestorsOf, classOf, nameOf} from \"@tsed/core\";\nimport {Inject, Injectable, InjectorService} from \"@tsed/di\";\nimport {PlatformContext} from \"../../platform/domain/PlatformContext\";\nimport \"../components/ErrorFilter\";\nimport \"../components/ExceptionFilter\";\nimport \"../components/StringErrorFilter\";\nimport \"../components/MongooseErrorFilter\";\nimport {ExceptionFilterKey, ExceptionFiltersContainer} from \"../domain/ExceptionFiltersContainer\";\nimport {ResourceNotFound} from \"../errors/ResourceNotFound\";\nimport {ExceptionFilterMethods} from \"../interfaces/ExceptionFilterMethods\";\n\n/**\n * Catch all errors and return the json error with the right status code when it's possible.\n *\n * @platform\n */\n@Injectable()\nexport class PlatformExceptions {\n  types: Map<ExceptionFilterKey, ExceptionFilterMethods> = new Map();\n\n  @Inject()\n  injector: InjectorService;\n\n  $onInit() {\n    ExceptionFiltersContainer.forEach((token, type) => {\n      this.types.set(type, this.injector.get(token)!);\n    });\n  }\n\n  catch(error: unknown, ctx: PlatformContext) {\n    const name = nameOf(classOf(error));\n\n    if (name && this.types.has(name)) {\n      return this.types.get(name)!.catch(error, ctx);\n    }\n\n    const target = ancestorsOf(error)\n      .reverse()\n      .find((target) => this.types.has(target));\n\n    if (target) {\n      return this.types.get(target)!.catch(error, ctx);\n    }\n  }\n\n  resourceNotFound(ctx: PlatformContext) {\n    return this.catch(new ResourceNotFound(ctx.request.url), ctx);\n  }\n}\n"]}