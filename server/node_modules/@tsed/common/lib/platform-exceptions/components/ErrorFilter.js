"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorFilter = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const catch_1 = require("../decorators/catch");
let ErrorFilter = class ErrorFilter {
    catch(error, ctx) {
        const { response, logger, env } = ctx;
        const err = this.mapError(error, env);
        logger.error({
            error: { ...err, stack: error.stack }
        });
        response
            .onEnd(() => {
            env === "development" && ctx.injector.logger.error(error);
        })
            .setHeaders(this.getHeaders(error))
            .status(err.status)
            .contentType("application/json")
            .body(env === core_1.Env.PROD ? "InternalServerError" : err);
    }
    mapError(error, env) {
        var _a;
        return {
            name: ((_a = error.origin) === null || _a === void 0 ? void 0 : _a.name) || error.name,
            message: error.message,
            status: error.status || 500,
            errors: this.getErrors(error),
            stack: env === core_1.Env.DEV ? error.stack : undefined
        };
    }
    getErrors(error) {
        return [error, error.origin].filter(Boolean).reduce((errs, { errors }) => {
            return [...errs, ...(errors || [])];
        }, []);
    }
    getHeaders(error) {
        return [error, error.origin].filter(Boolean).reduce((obj, { headers }) => {
            return {
                ...obj,
                ...(headers || {})
            };
        }, {});
    }
};
ErrorFilter = tslib_1.__decorate([
    catch_1.Catch(Error)
], ErrorFilter);
exports.ErrorFilter = ErrorFilter;
//# sourceMappingURL=ErrorFilter.js.map