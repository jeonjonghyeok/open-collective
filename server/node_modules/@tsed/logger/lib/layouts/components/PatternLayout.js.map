{"version":3,"file":"PatternLayout.js","sourceRoot":"","sources":["../../../src/layouts/components/PatternLayout.ts"],"names":[],"mappings":";;;AAAA,sDAAoD;AACpD,oDAA+C;AAE/C,4DAAuD;AAGvD,iDAA4C;AAE5C,MAAM,KAAK,GAAG,kEAAkE,CAAC;AACjF,MAAM,uBAAuB,GAAG,iBAAiB,CAAC;AAElD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BG;AAEH,IAAa,aAAa,GAA1B,MAAa,aAAc,SAAQ,uBAAU;IAK3C,YAAY,MAAiC;QAC3C,KAAK,CAAC,MAAM,CAAC,CAAC;QAyCR,iBAAY,GAAG,CAAC,mBAA2B,EAAE,YAAiB,EAAE,SAAc,EAAE,EAAE;YACxF,OAAO,IAAI,CAAC,UAAU,CAAC,mBAAmB,CAAC,CAAC,YAAY,EAAE,SAAS,CAAC,CAAC;QACvE,CAAC,CAAC;QAzCA,IAAI,CAAC,OAAO,GAAG,CAAC,MAAM,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,uBAAuB,CAAC;QACrE,IAAI,CAAC,MAAM,GAAG,MAAM,IAAI,MAAM,CAAC,MAAO,CAAC;QACvC,IAAI,CAAC,UAAU,GAAG,IAAI,+BAAc,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,KAAK,EAAE,CAAC;IACxF,CAAC;IAED;;;;;OAKG;IACH,SAAS,CAAC,YAAsB,EAAE,cAAuB;QACvD,IAAI,eAAe,GAAG,EAAE,CAAC;QACzB,IAAI,MAAM,CAAC;QACX,IAAI,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC;QAEhC,6BAA6B;QAC7B,OAAO,CAAC,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,KAAK,IAAI,EAAE;YACnD,mCAAmC;YACnC,MAAM,OAAO,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YAC1B,MAAM,UAAU,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YAC7B,MAAM,mBAAmB,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YACtC,MAAM,SAAS,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YAC5B,MAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YAEvB,oDAAoD;YACpD,IAAI,IAAI,EAAE;gBACR,eAAe,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;aACpC;iBAAM;gBACL,0DAA0D;gBAC1D,0BAA0B;gBAC1B,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,mBAAmB,EAAE,YAAY,EAAE,SAAS,CAAC,CAAC;gBACpF,eAAe,IAAI,4BAAc,CAAC,WAAW,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;aACrE;YACD,YAAY,GAAG,YAAY,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;SACrE;QACD,OAAO,eAAe,CAAC;IACzB,CAAC;CAKF,CAAA;AAlDY,aAAa;IADzB,eAAM,CAAC,EAAC,IAAI,EAAE,SAAS,EAAC,CAAC;;GACb,aAAa,CAkDzB;AAlDY,sCAAa","sourcesContent":["import {truncateAndPad} from \"../utils/StringUtils\";\nimport {BaseLayout} from \"../class/BaseLayout\";\nimport {IReplacers} from \"../interfaces/Replacers\";\nimport {LayoutReplacer} from \"../class/LayoutReplacer\";\nimport {LogEvent} from \"../../core/LogEvent\";\nimport {IBasicLayoutConfiguration, TokensHandlers} from \"../interfaces/BasicLayoutConfiguration\";\nimport {Layout} from \"../decorators/layout\";\n\nconst regex = /%(-?[0-9]+)?(\\.?[0-9]+)?([[\\]cdhmnprzxy%])(\\{([^}]+)\\})?|([^%]+)/;\nconst TTCC_CONVERSION_PATTERN = \"%r %p %c - %m%n\";\n\n/**\n * PatternLayout\n * Format for specifiers is %[padding].[truncation][field]{[format]}\n * e.g. %5.10p - left pad the log level by 5 characters, up to a max of 10\n * Fields can be any of:\n *  - %r time in toLocaleTimeString format\n *  - %p log level\n *  - %c log category\n *  - %h hostname\n *  - %m log data\n *  - %d date in constious formats\n *  - %% %\n *  - %n newline\n *  - %z pid\n *  - %x{[tokenname]} add dynamic tokens to your log. Tokens are specified in the tokens parameter\n * You can use %[ and %] to define a colored block.\n *\n * Tokens are specified as simple key:value objects.\n * The key represents the token name whereas the value can be a string or function\n * which is called to extract the value to put in the log message. If token is not\n * found, it doesn't replace the field.\n *\n * A sample token would be: { 'pid' : function() { return process.pid; } }\n *\n * Takes a pattern string, array of tokens and returns a layouts function.\n * @return {Function}\n * @param pattern\n * @param tokens\n * @param timezoneOffset\n *\n * @authors ['Stephan Strittmatter', 'Jan Schmidle']\n */\n@Layout({name: \"pattern\"})\nexport class PatternLayout extends BaseLayout {\n  private _replacers: IReplacers;\n  private tokens: TokensHandlers;\n  private pattern: string;\n\n  constructor(config: IBasicLayoutConfiguration) {\n    super(config);\n\n    this.pattern = (config && config.pattern) || TTCC_CONVERSION_PATTERN;\n    this.tokens = config && config.tokens!;\n    this._replacers = new LayoutReplacer(this.tokens, this.config.timezoneOffset).build();\n  }\n\n  /**\n   *\n   * @param loggingEvent\n   * @param timezoneOffset\n   * @returns {string}\n   */\n  transform(loggingEvent: LogEvent, timezoneOffset?: number): string {\n    let formattedString = \"\";\n    let result;\n    let searchString = this.pattern;\n\n    /* eslint no-cond-assign:0 */\n    while ((result = regex.exec(searchString)) !== null) {\n      // const matchedString = result[0];\n      const padding = result[1];\n      const truncation = result[2];\n      const conversionCharacter = result[3];\n      const specifier = result[5];\n      const text = result[6];\n\n      // Check if the pattern matched was just normal text\n      if (text) {\n        formattedString += text.toString();\n      } else {\n        // Create a raw replacement string based on the conversion\n        // character and specifier\n        const replacement = this.replaceToken(conversionCharacter, loggingEvent, specifier);\n        formattedString += truncateAndPad(replacement, truncation, padding);\n      }\n      searchString = searchString.substr(result.index + result[0].length);\n    }\n    return formattedString;\n  }\n\n  private replaceToken = (conversionCharacter: string, loggingEvent: any, specifier: any) => {\n    return this._replacers[conversionCharacter](loggingEvent, specifier);\n  };\n}\n"]}