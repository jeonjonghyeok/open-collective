{"version":3,"file":"useOpts.js","sourceRoot":"","sources":["../../src/decorators/useOpts.ts"],"names":[],"mappings":";;;AAAA,qCAA6F;AAC7F,4CAA+D;AAE/D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsCG;AACH,SAAgB,OAAO,CAAC,OAA6B;IACnD,OAAO,CAAC,MAAc,EAAE,WAA4B,EAAE,KAAc,EAAO,EAAE;QAC3E,MAAM,WAAW,GAAG,uBAAgB,CAAC,CAAC,MAAM,EAAE,WAAW,EAAE,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;QAEzE,QAAQ,WAAW,EAAE;YACnB,KAAK,qBAAc,CAAC,UAAU;gBAC5B,YAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,GAAG,4BAAgB,IAAI,KAAK,EAAE,EAAE,OAAO,CAAC,CAAC;gBAClE,MAAM;YAER,KAAK,qBAAc,CAAC,IAAI;gBACtB,YAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,2BAAe,EAAE;oBACxC,CAAC,WAAqB,CAAC,EAAE;wBACvB,OAAO;qBACR;iBACF,CAAC,CAAC;gBACH,MAAM;YAER;gBACE,MAAM,IAAI,+BAAwB,CAAC,OAAO,EAAE,CAAC,MAAM,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC;SAC7E;IACH,CAAC,CAAC;AACJ,CAAC;AArBD,0BAqBC","sourcesContent":["import {DecoratorTypes, getDecoratorType, Store, UnsupportedDecoratorType} from \"@tsed/core\";\nimport {DI_PARAM_OPTIONS, INJECTABLE_PROP} from \"../constants\";\n\n/**\n * Add options to invoke the Service.\n *\n * ```typescript\n * import {Injectable, Opts, UseOpts} from \"@tsed/di\";\n *\n * @Injectable()\n * class MyConfigurableService {\n *   source: string;\n *   constructor(@Opts options: any = {}) {\n *      console.log(\"Hello \", options.source); // log: Hello Service1 then Hello Service2\n *\n *      this.source = options.source;\n *   }\n * }\n *\n * @Injectable()\n * class MyService1 {\n *   constructor(@UseOpts({source: 'Service1'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service1\n *   }\n * }\n *\n * @Injectable()\n * class MyService2 {\n *   constructor(@UseOpts({source: 'Service2'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service2\n *   }\n * }\n * ```\n *\n * ::: warning\n * Using @@Opts@@ decorator on a constructor parameter change the Scope of the provider to `ProviderScope.INSTANCE`.\n * :::\n *\n * @returns {Function}\n * @decorator\n * @param options\n */\nexport function UseOpts(options: {[key: string]: any}): Function {\n  return (target: Object, propertyKey: string | symbol, index?: number): any => {\n    const bindingType = getDecoratorType([target, propertyKey, index], true);\n\n    switch (bindingType) {\n      case DecoratorTypes.PARAM_CTOR:\n        Store.from(target).merge(`${DI_PARAM_OPTIONS}:${index}`, options);\n        break;\n\n      case DecoratorTypes.PROP:\n        Store.from(target).merge(INJECTABLE_PROP, {\n          [propertyKey as string]: {\n            options\n          }\n        });\n        break;\n\n      default:\n        throw new UnsupportedDecoratorType(UseOpts, [target, propertyKey, index]);\n    }\n  };\n}\n"]}