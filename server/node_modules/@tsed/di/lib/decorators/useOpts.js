"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UseOpts = void 0;
const core_1 = require("@tsed/core");
const constants_1 = require("../constants");
/**
 * Add options to invoke the Service.
 *
 * ```typescript
 * import {Injectable, Opts, UseOpts} from "@tsed/di";
 *
 * @Injectable()
 * class MyConfigurableService {
 *   source: string;
 *   constructor(@Opts options: any = {}) {
 *      console.log("Hello ", options.source); // log: Hello Service1 then Hello Service2
 *
 *      this.source = options.source;
 *   }
 * }
 *
 * @Injectable()
 * class MyService1 {
 *   constructor(@UseOpts({source: 'Service1'}) service: MyConfigurableService) {
 *     console.log(service.source) // log: Service1
 *   }
 * }
 *
 * @Injectable()
 * class MyService2 {
 *   constructor(@UseOpts({source: 'Service2'}) service: MyConfigurableService) {
 *     console.log(service.source) // log: Service2
 *   }
 * }
 * ```
 *
 * ::: warning
 * Using @@Opts@@ decorator on a constructor parameter change the Scope of the provider to `ProviderScope.INSTANCE`.
 * :::
 *
 * @returns {Function}
 * @decorator
 * @param options
 */
function UseOpts(options) {
    return (target, propertyKey, index) => {
        const bindingType = core_1.getDecoratorType([target, propertyKey, index], true);
        switch (bindingType) {
            case core_1.DecoratorTypes.PARAM_CTOR:
                core_1.Store.from(target).merge(`${constants_1.DI_PARAM_OPTIONS}:${index}`, options);
                break;
            case core_1.DecoratorTypes.PROP:
                core_1.Store.from(target).merge(constants_1.INJECTABLE_PROP, {
                    [propertyKey]: {
                        options
                    }
                });
                break;
            default:
                throw new core_1.UnsupportedDecoratorType(UseOpts, [target, propertyKey, index]);
        }
    };
}
exports.UseOpts = UseOpts;
//# sourceMappingURL=useOpts.js.map