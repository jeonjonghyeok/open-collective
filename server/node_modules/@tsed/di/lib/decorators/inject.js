"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Inject = void 0;
const core_1 = require("@tsed/core");
const constants_1 = require("../constants");
/**
 * Inject a provider to another provider.
 *
 * Use this decorator to inject a custom provider on constructor parameter or property.
 *
 * ```typescript
 * @Injectable()
 * export class MyService {
 *   @Inject(CONNECTION)
 *   connection: CONNECTION;
 * }
 * ```
 *
 * @param symbol
 * @returns {Function}
 * @decorator
 */
function Inject(symbol) {
    return (target, propertyKey, descriptor) => {
        const bindingType = core_1.getDecoratorType([target, propertyKey, descriptor], true);
        switch (bindingType) {
            case core_1.DecoratorTypes.PARAM:
            case core_1.DecoratorTypes.PARAM_CTOR:
                if (symbol) {
                    const paramTypes = core_1.Metadata.getParamTypes(target, propertyKey);
                    paramTypes[descriptor] = symbol;
                    core_1.Metadata.setParamTypes(target, propertyKey, paramTypes);
                }
                break;
            case core_1.DecoratorTypes.PROP:
                core_1.Store.from(target).merge(constants_1.INJECTABLE_PROP, {
                    [propertyKey]: {
                        bindingType,
                        propertyKey,
                        useType: symbol || core_1.Metadata.getType(target, propertyKey)
                    }
                });
                break;
            case core_1.DecoratorTypes.METHOD:
                core_1.Store.from(target).merge(constants_1.INJECTABLE_PROP, {
                    [propertyKey]: {
                        bindingType,
                        propertyKey
                    }
                });
                return descriptor;
            default:
                throw new core_1.UnsupportedDecoratorType(Inject, [target, propertyKey, descriptor]);
        }
    };
}
exports.Inject = Inject;
//# sourceMappingURL=inject.js.map