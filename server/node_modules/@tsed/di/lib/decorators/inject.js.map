{"version":3,"file":"inject.js","sourceRoot":"","sources":["../../src/decorators/inject.ts"],"names":[],"mappings":";;;AAAA,qCAAuG;AACvG,4CAA6C;AAE7C;;;;;;;;;;;;;;;;GAgBG;AACH,SAAgB,MAAM,CAAC,MAAY;IACjC,OAAO,CAAC,MAAW,EAAE,WAAmB,EAAE,UAAsD,EAAO,EAAE;QACvG,MAAM,WAAW,GAAG,uBAAgB,CAAC,CAAC,MAAM,EAAE,WAAW,EAAE,UAAU,CAAC,EAAE,IAAI,CAAC,CAAC;QAE9E,QAAQ,WAAW,EAAE;YACnB,KAAK,qBAAc,CAAC,KAAK,CAAC;YAC1B,KAAK,qBAAc,CAAC,UAAU;gBAC5B,IAAI,MAAM,EAAE;oBACV,MAAM,UAAU,GAAG,eAAQ,CAAC,aAAa,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;oBAE/D,UAAU,CAAC,UAAoB,CAAC,GAAG,MAAM,CAAC;oBAC1C,eAAQ,CAAC,aAAa,CAAC,MAAM,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;iBACzD;gBACD,MAAM;YAER,KAAK,qBAAc,CAAC,IAAI;gBACtB,YAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,2BAAe,EAAE;oBACxC,CAAC,WAAW,CAAC,EAAE;wBACb,WAAW;wBACX,WAAW;wBACX,OAAO,EAAE,MAAM,IAAI,eAAQ,CAAC,OAAO,CAAC,MAAM,EAAE,WAAW,CAAC;qBACzD;iBACF,CAAC,CAAC;gBACH,MAAM;YAER,KAAK,qBAAc,CAAC,MAAM;gBACxB,YAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,2BAAe,EAAE;oBACxC,CAAC,WAAW,CAAC,EAAE;wBACb,WAAW;wBACX,WAAW;qBACZ;iBACF,CAAC,CAAC;gBAEH,OAAO,UAAU,CAAC;YAEpB;gBACE,MAAM,IAAI,+BAAwB,CAAC,MAAM,EAAE,CAAC,MAAM,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC,CAAC;SACjF;IACH,CAAC,CAAC;AACJ,CAAC;AAvCD,wBAuCC","sourcesContent":["import {DecoratorTypes, getDecoratorType, Metadata, Store, UnsupportedDecoratorType} from \"@tsed/core\";\nimport {INJECTABLE_PROP} from \"../constants\";\n\n/**\n * Inject a provider to another provider.\n *\n * Use this decorator to inject a custom provider on constructor parameter or property.\n *\n * ```typescript\n * @Injectable()\n * export class MyService {\n *   @Inject(CONNECTION)\n *   connection: CONNECTION;\n * }\n * ```\n *\n * @param symbol\n * @returns {Function}\n * @decorator\n */\nexport function Inject(symbol?: any): Function {\n  return (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<Function> | number): any => {\n    const bindingType = getDecoratorType([target, propertyKey, descriptor], true);\n\n    switch (bindingType) {\n      case DecoratorTypes.PARAM:\n      case DecoratorTypes.PARAM_CTOR:\n        if (symbol) {\n          const paramTypes = Metadata.getParamTypes(target, propertyKey);\n\n          paramTypes[descriptor as number] = symbol;\n          Metadata.setParamTypes(target, propertyKey, paramTypes);\n        }\n        break;\n\n      case DecoratorTypes.PROP:\n        Store.from(target).merge(INJECTABLE_PROP, {\n          [propertyKey]: {\n            bindingType,\n            propertyKey,\n            useType: symbol || Metadata.getType(target, propertyKey)\n          }\n        });\n        break;\n\n      case DecoratorTypes.METHOD:\n        Store.from(target).merge(INJECTABLE_PROP, {\n          [propertyKey]: {\n            bindingType,\n            propertyKey\n          }\n        });\n\n        return descriptor;\n\n      default:\n        throw new UnsupportedDecoratorType(Inject, [target, propertyKey, descriptor]);\n    }\n  };\n}\n"]}