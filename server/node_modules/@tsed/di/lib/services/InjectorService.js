"use strict";
var InjectorService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.InjectorService = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const Container_1 = require("../class/Container");
const LocalsContainer_1 = require("../class/LocalsContainer");
const Provider_1 = require("../class/Provider");
const constants_1 = require("../constants");
const configuration_1 = require("../decorators/configuration");
const injectable_1 = require("../decorators/injectable");
const InjectionError_1 = require("../errors/InjectionError");
const UndefinedTokenError_1 = require("../errors/UndefinedTokenError");
const interfaces_1 = require("../interfaces");
const GlobalProviders_1 = require("../registries/GlobalProviders");
const DIConfiguration_1 = require("./DIConfiguration");
const createContainer_1 = require("../utils/createContainer");
/**
 * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.
 *
 * ### Example:
 *
 * ```typescript
 * import {InjectorService} from "@tsed/di";
 *
 * // Import the services (all services are decorated with @Service()";
 * import MyService1 from "./services/service1";
 * import MyService2 from "./services/service2";
 * import MyService3 from "./services/service3";
 *
 * // When all services is imported you can load InjectorService.
 * const injector = new InjectorService()
 *
 * await injector.load();
 *
 * const myService1 = injector.get<MyService1>(MyServcice1);
 * ```
 */
let InjectorService = InjectorService_1 = class InjectorService extends Container_1.Container {
    constructor() {
        super();
        this.settings = new DIConfiguration_1.DIConfiguration();
        this.logger = console;
        this.resolvedConfiguration = false;
        const provider = this.addProvider(InjectorService_1).getProvider(InjectorService_1);
        provider.instance = this;
    }
    get resolvers() {
        return this.settings.resolvers;
    }
    get scopes() {
        return this.settings.scopes;
    }
    /**
     * Retrieve default scope for a given provider.
     * @param provider
     */
    scopeOf(provider) {
        return provider.scope || this.scopes[provider.type] || interfaces_1.ProviderScope.SINGLETON;
    }
    /**
     * Clone a provider from GlobalProviders and the given token. forkProvider method build automatically the provider if the instance parameter ins't given.
     * @param token
     * @param settings
     */
    forkProvider(token, settings = {}) {
        if (!this.hasProvider(token)) {
            this.addProvider(token);
        }
        const provider = this.getProvider(token);
        Object.assign(provider, settings);
        provider.instance = this.invoke(token);
        return provider;
    }
    /**
     * Return a list of instance build by the injector.
     */
    toArray() {
        return super.toArray().map((provider) => provider.instance);
    }
    /**
     * Get a service or factory already constructed from his symbol or class.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/di";
     * import MyService from "./services";
     *
     * class OtherService {
     *      constructor(injectorService: InjectorService) {
     *          const myService = injectorService.get<MyService>(MyService);
     *      }
     * }
     * ```
     *
     * @param token The class or symbol registered in InjectorService.
     * @param options
     * @returns {boolean}
     */
    get(token, options = {}) {
        const instance = super.has(token) && super.get(core_1.getClassOrSymbol(token)).instance;
        if (instance) {
            return instance;
        }
        if (!this.hasProvider(token)) {
            for (const resolver of this.resolvers) {
                const result = resolver.get(token, options);
                if (result !== undefined) {
                    return result;
                }
            }
        }
    }
    /**
     * The has() method returns a boolean indicating whether an element with the specified key exists or not.
     * @returns {boolean}
     * @param token
     */
    has(token) {
        return super.has(core_1.getClassOrSymbol(token)) && !!this.get(token);
    }
    /**
     * Invoke the class and inject all services that required by the class constructor.
     *
     * #### Example
     *
     * ```typescript
     * import {InjectorService} from "@tsed/di";
     * import MyService from "./services";
     *
     * class OtherService {
     *     constructor(injectorService: InjectorService) {
     *          const myService = injectorService.invoke<MyService>(MyService);
     *      }
     *  }
     * ```
     *
     * @param token The injectable class to invoke. Class parameters are injected according constructor signature.
     * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     * @param options
     * @returns {T} The class constructed.
     */
    invoke(token, locals = new LocalsContainer_1.LocalsContainer(), options = {}) {
        const provider = this.ensureProvider(token);
        let instance;
        !locals.has(configuration_1.Configuration) && locals.set(configuration_1.Configuration, this.settings);
        if (locals.has(token)) {
            return locals.get(token);
        }
        if (token === constants_1.DI_PARAM_OPTIONS) {
            return {};
        }
        if (!provider || options.rebuild) {
            instance = this.resolve(token, locals, options);
            this.hasProvider(token) && (this.getProvider(token).instance = instance);
            return instance;
        }
        switch (this.scopeOf(provider)) {
            case interfaces_1.ProviderScope.SINGLETON:
                if (!this.has(token)) {
                    provider.instance = this.resolve(token, locals, options);
                    if (provider.isAsync()) {
                        provider.instance.then((instance) => {
                            provider.instance = instance;
                        });
                    }
                }
                instance = this.get(token);
                break;
            case interfaces_1.ProviderScope.REQUEST:
                instance = this.resolve(token, locals, options);
                locals.set(token, instance);
                break;
            case interfaces_1.ProviderScope.INSTANCE:
                instance = this.resolve(provider.provide, locals, options);
                break;
        }
        return instance;
    }
    /**
     * Build only providers which are asynchronous.
     */
    async loadAsync(locals = new LocalsContainer_1.LocalsContainer()) {
        const providers = super.toArray();
        for (const provider of providers) {
            if (!locals.has(provider.token)) {
                if (provider.isAsync()) {
                    await this.invoke(provider.token, locals);
                }
                if (provider.instance) {
                    locals.set(provider.token, provider.instance);
                }
            }
        }
        return locals;
    }
    loadSync(locals = new LocalsContainer_1.LocalsContainer()) {
        const providers = super.toArray();
        for (const provider of providers) {
            if (!locals.has(provider.token) && this.scopeOf(provider) === interfaces_1.ProviderScope.SINGLETON) {
                this.invoke(provider.token, locals);
            }
            if (provider.instance) {
                locals.set(provider.token, provider.instance);
            }
        }
        return locals;
    }
    /**
     * Boostrap injector from container and resolve configuration.
     *
     * @param container
     */
    bootstrap(container = createContainer_1.createContainer()) {
        // Clone all providers in the container
        this.addProviders(container);
        // Resolve all configuration
        this.resolveConfiguration();
        return this;
    }
    /**
     * Build all providers from given container (or GlobalProviders) and emit `$onInit` event.
     *
     * @param container
     */
    async load(container = createContainer_1.createContainer()) {
        this.bootstrap(container);
        // build async and sync provider
        let locals = await this.loadAsync();
        // load sync provider
        locals = this.loadSync(locals);
        await locals.emit("$onInit");
        return locals;
    }
    /**
     * Load all configurations registered on providers
     */
    resolveConfiguration() {
        if (this.resolvedConfiguration) {
            return;
        }
        const mergedConfiguration = new Map();
        super.forEach((provider) => {
            if (provider.configuration) {
                Object.entries(provider.configuration).forEach(([key, value]) => {
                    mergedConfiguration.set(key, mergedConfiguration.has(key) ? core_1.deepExtends(mergedConfiguration.get(key), value) : core_1.deepClone(value));
                });
            }
            if (provider.resolvers) {
                this.resolvers.push(...provider.resolvers);
            }
        });
        mergedConfiguration.forEach((value, key) => {
            this.settings[key] = core_1.deepExtends(value, this.settings[key]);
        });
        this.settings.build();
        this.resolvedConfiguration = true;
    }
    /**
     *
     * @param instance
     * @param locals
     * @param options
     */
    bindInjectableProperties(instance, locals, options) {
        const properties = core_1.ancestorsOf(core_1.classOf(instance)).reduce((properties, target) => {
            const store = core_1.Store.from(target);
            return {
                ...properties,
                ...(store.get(constants_1.INJECTABLE_PROP) || {})
            };
        }, {});
        Object.values(properties).forEach((definition) => {
            switch (definition.bindingType) {
                case interfaces_1.InjectablePropertyType.METHOD:
                    this.bindMethod(instance, definition);
                    break;
                case interfaces_1.InjectablePropertyType.PROPERTY:
                    this.bindProperty(instance, definition, locals, options);
                    break;
                case interfaces_1.InjectablePropertyType.CONSTANT:
                    this.bindConstant(instance, definition);
                    break;
                case interfaces_1.InjectablePropertyType.VALUE:
                    this.bindValue(instance, definition);
                    break;
                case interfaces_1.InjectablePropertyType.INTERCEPTOR:
                    this.bindInterceptor(instance, definition);
                    break;
            }
        });
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     */
    bindMethod(instance, { propertyKey }) {
        const target = core_1.classOf(instance);
        const originalMethod = instance[propertyKey];
        const deps = core_1.Metadata.getParamTypes(core_1.prototypeOf(target), propertyKey);
        instance[propertyKey] = () => {
            const services = deps.map((dependency) => this.get(dependency));
            return originalMethod.call(instance, ...services);
        };
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     * @param options
     * @param locals
     * @param invokeOptions
     */
    bindProperty(instance, { propertyKey, useType, options }, locals, invokeOptions) {
        invokeOptions = { ...invokeOptions };
        locals.set(constants_1.DI_PARAM_OPTIONS, { ...options });
        let bean = this.invoke(useType, locals, invokeOptions);
        locals.delete(constants_1.DI_PARAM_OPTIONS);
        if (core_1.isPromise(bean)) {
            bean.then((result) => {
                bean = result;
            });
        }
        Object.defineProperty(instance, propertyKey, {
            get: () => bean
        });
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    bindValue(instance, { propertyKey, expression, defaultValue }) {
        const descriptor = {
            get: () => this.settings.get(expression) || defaultValue,
            set: (value) => this.settings.set(expression, value),
            enumerable: true,
            configurable: true
        };
        Object.defineProperty(instance, propertyKey, descriptor);
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {any} useType
     */
    bindConstant(instance, { propertyKey, expression, defaultValue }) {
        const clone = (o) => {
            if (o) {
                return Object.freeze(core_1.deepClone(o));
            }
            return defaultValue;
        };
        const descriptor = {
            get: () => clone(this.settings.get(expression)),
            enumerable: true,
            configurable: true
        };
        Object.defineProperty(instance, propertyKey, descriptor);
        return descriptor;
    }
    /**
     *
     * @param instance
     * @param propertyKey
     * @param useType
     * @param options
     */
    bindInterceptor(instance, { propertyKey, useType, options }) {
        const target = core_1.classOf(instance);
        const originalMethod = instance[propertyKey];
        instance[propertyKey] = (...args) => {
            const next = (err) => {
                if (!err) {
                    return originalMethod.apply(instance, args);
                }
                throw err;
            };
            const context = {
                target,
                propertyKey,
                args,
                options,
                next
            };
            const interceptor = this.get(useType);
            return interceptor.intercept({
                ...context,
                options
            }, next);
        };
    }
    ensureProvider(token) {
        if (!this.hasProvider(token) && GlobalProviders_1.GlobalProviders.has(token)) {
            this.addProvider(token);
        }
        return this.getProvider(token);
    }
    /**
     * Invoke a class method and inject service.
     *
     * #### IInjectableMethod options
     *
     * * **target**: Optional. The class instance.
     * * **methodName**: `string` Optional. The method name.
     * * **designParamTypes**: `any[]` Optional. List of injectable types.
     * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.
     *
     * #### Example
     *
     * @param target
     * @param locals
     * @param options
     * @private
     */
    resolve(target, locals, options = {}) {
        const { token, deps, construct, isBindable, imports, provider } = this.mapInvokeOptions(target, locals, options);
        if (provider) {
            if (!provider.injectable && options.parent) {
                throw new InjectionError_1.InjectionError(token, `${core_1.nameOf(token)} ${provider.type} is not injectable to another provider`);
            }
            const { onInvoke } = GlobalProviders_1.GlobalProviders.getRegistrySettings(target);
            if (onInvoke) {
                onInvoke(provider, locals, deps);
            }
        }
        let instance;
        let currentDependency = false;
        try {
            const invokeDependency = (parent) => (token, index) => {
                var _a;
                currentDependency = { token, index, deps };
                if (token !== constants_1.DI_PARAM_OPTIONS) {
                    const options = (_a = provider === null || provider === void 0 ? void 0 : provider.store) === null || _a === void 0 ? void 0 : _a.get(`${constants_1.DI_PARAM_OPTIONS}:${index}`);
                    locals.set(constants_1.DI_PARAM_OPTIONS, options || {});
                }
                return core_1.isInheritedFrom(token, Provider_1.Provider, 1) ? provider : this.invoke(token, locals, { parent });
            };
            // Invoke manually imported providers
            imports.forEach(invokeDependency());
            // Inject dependencies
            const services = deps.map(invokeDependency(token));
            currentDependency = false;
            instance = construct(services);
        }
        catch (error) {
            InjectionError_1.InjectionError.throwInjectorError(token, currentDependency, error);
        }
        if (instance === undefined) {
            throw new InjectionError_1.InjectionError(token, `Unable to create new instance from undefined value. Check your provider declaration for ${core_1.nameOf(token)}`);
        }
        if (instance && isBindable) {
            this.bindInjectableProperties(instance, locals, options);
        }
        return instance;
    }
    /**
     * Create options to invoke a provider or class.
     * @param token
     * @param locals
     * @param options
     */
    mapInvokeOptions(token, locals, options) {
        let imports = options.imports;
        let deps = options.deps;
        let scope = options.scope;
        let construct;
        let isBindable = false;
        if (!token) {
            throw new UndefinedTokenError_1.UndefinedTokenError();
        }
        let provider;
        if (!this.hasProvider(token)) {
            provider = new Provider_1.Provider(token);
            this.resolvers.forEach((resolver) => {
                const result = resolver.get(token, locals.get(constants_1.DI_PARAM_OPTIONS));
                if (result !== undefined) {
                    provider.useFactory = () => result;
                }
            });
        }
        else {
            provider = this.getProvider(token);
        }
        scope = scope || this.scopeOf(provider);
        deps = deps || provider.deps;
        imports = imports || provider.imports;
        if (provider.useValue) {
            construct = () => (core_1.isFunction(provider.useValue) ? provider.useValue() : provider.useValue);
        }
        else if (provider.useFactory) {
            construct = (deps) => provider.useFactory(...deps);
        }
        else if (provider.useAsyncFactory) {
            construct = (deps) => provider.useAsyncFactory(...deps);
        }
        else {
            // useClass
            isBindable = true;
            deps = deps || core_1.Metadata.getParamTypes(provider.useClass);
            construct = (deps) => new provider.useClass(...deps);
        }
        return {
            token,
            scope: scope || core_1.Store.from(token).get("scope") || interfaces_1.ProviderScope.SINGLETON,
            deps: deps || [],
            imports: imports || [],
            isBindable,
            construct,
            provider
        };
    }
};
InjectorService = InjectorService_1 = tslib_1.__decorate([
    injectable_1.Injectable({
        scope: interfaces_1.ProviderScope.SINGLETON,
        global: true
    }),
    tslib_1.__metadata("design:paramtypes", [])
], InjectorService);
exports.InjectorService = InjectorService;
//# sourceMappingURL=InjectorService.js.map