"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AjvErrorFormatterPipe = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@tsed/common");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const AjvValidationError_1 = require("../errors/AjvValidationError");
function defaultFormatter(error) {
    const value = JSON.stringify(error.data === undefined ? "undefined" : error.data);
    const join = (list) => list.filter(Boolean).join("").trim();
    if (error.collectionName) {
        switch (error.collectionName) {
            case "Map":
                return join([
                    error.dataPath.replace("['", "Map<").replace("']", `, ${error.modelName || ""}>`),
                    ` ${error.message}. Given value: ${value}`
                ]);
            case "Set":
                return join([
                    error.dataPath.replace("[", "Set<").replace("]", `, ${error.modelName || ""}>`),
                    ` ${error.message}. Given value: ${value}`
                ]);
        }
    }
    return join([
        !error.modelName && "Value",
        // index !== undefined && !error.modelName && ".",
        // index !== undefined && !isNaN(+index) && `[${index}]`,
        // index !== undefined && isNaN(+index) && `${index}`,
        // index !== undefined && error.modelName && isNaN(+index) && ".",
        `${error.modelName || ""}`,
        error.dataPath,
        ` ${error.message}. Given value: ${value}`
    ]);
}
let AjvErrorFormatterPipe = class AjvErrorFormatterPipe {
    transform(errors, options) {
        const { type, collectionType, value } = options;
        const message = errors
            .map((error) => {
            if (collectionType) {
                error.collectionName = core_1.nameOf(collectionType);
            }
            if (!error.data) {
                if (error.dataPath) {
                    error.data = core_1.getValue(error.dataPath.replace(/^./, ""), value);
                }
                else if (error.schemaPath !== "#/required") {
                    error.data = value;
                }
            }
            if (error.dataPath && error.dataPath.match(/pwd|password|mdp|secret/)) {
                error.data = "[REDACTED]";
            }
            if (type) {
                error.modelName = core_1.nameOf(type);
                error.message = this.mapClassError(error, type);
            }
            return this.errorFormatter.call(this, error, {});
        })
            .join("\n");
        return new AjvValidationError_1.AjvValidationError(message, errors);
    }
    mapClassError(error, targetType) {
        const propertyKey = core_1.getValue(error, "params.missingProperty");
        if (propertyKey) {
            const prop = common_1.PropertyMetadata.get(targetType, propertyKey);
            if (prop) {
                core_1.setValue(error, "params.missingProperty", prop.name || propertyKey);
                return error.message.replace(`'${propertyKey}'`, `'${prop.name || propertyKey}'`);
            }
        }
        return error.message;
    }
};
tslib_1.__decorate([
    common_1.Constant("ajv.errorFormatter", defaultFormatter),
    tslib_1.__metadata("design:type", Function)
], AjvErrorFormatterPipe.prototype, "errorFormatter", void 0);
AjvErrorFormatterPipe = tslib_1.__decorate([
    di_1.Injectable()
], AjvErrorFormatterPipe);
exports.AjvErrorFormatterPipe = AjvErrorFormatterPipe;
//# sourceMappingURL=AjvErrorFormatterPipe.js.map