"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useMethodDecorators = exports.useMethodDecorator = exports.useDecorators = exports.applyDecorators = exports.decorateMethodsOf = exports.decoratorArgs = exports.UnsupportedDecoratorType = exports.decoratorTypeOf = exports.getDecoratorType = exports.DecoratorTypes = void 0;
const ObjectUtils_1 = require("./ObjectUtils");
var DecoratorTypes;
(function (DecoratorTypes) {
    DecoratorTypes["PARAM"] = "parameter";
    DecoratorTypes["PARAM_CTOR"] = "parameter.constructor";
    DecoratorTypes["PARAM_STC"] = "parameter.static";
    DecoratorTypes["PROP"] = "property";
    DecoratorTypes["PROP_STC"] = "property.static";
    DecoratorTypes["METHOD"] = "method";
    DecoratorTypes["METHOD_STC"] = "method.static";
    DecoratorTypes["CLASS"] = "class";
})(DecoratorTypes = exports.DecoratorTypes || (exports.DecoratorTypes = {}));
/**
 *
 * @param {any[]} args
 * @param longType
 * @returns {"parameter" | "property" | "property.static" | "method" | "method.static" | "class"}
 */
function getDecoratorType(args, longType = false) {
    const [target, propertyKey, descriptor] = args;
    const staticType = (type) => {
        if (!longType) {
            return type;
        }
        return target !== ObjectUtils_1.getClass(target) ? type : (type + ".static");
    };
    if (typeof descriptor === "number") {
        return propertyKey ? staticType("parameter") : longType ? "parameter.constructor" : "parameter";
    }
    if ((propertyKey && descriptor === undefined) || (descriptor && (descriptor.get || descriptor.set))) {
        return staticType("property");
    }
    return descriptor && descriptor.value ? staticType("method") : "class";
}
exports.getDecoratorType = getDecoratorType;
/* istanbul ignore next */
function decoratorTypeOf(args) {
    return getDecoratorType(args, true);
}
exports.decoratorTypeOf = decoratorTypeOf;
/**
 *
 */
class UnsupportedDecoratorType extends Error {
    constructor(decorator, args) {
        super(UnsupportedDecoratorType.buildMessage(decorator, args));
    }
    static buildMessage(decorator, args) {
        const [target, propertyKey, index] = args;
        const bindingType = getDecoratorType(args, true);
        const shortBinding = bindingType.split("/")[0];
        const param = shortBinding === "parameter" ? ".[" + index + "]" : "";
        const cstr = shortBinding === "parameter" ? ".constructor" : "";
        const method = propertyKey ? "." + propertyKey : cstr;
        const path = ObjectUtils_1.nameOf(ObjectUtils_1.getClass(target)) + method + param;
        return `${decorator.name} cannot be used as ${bindingType} decorator on ${path}`;
    }
}
exports.UnsupportedDecoratorType = UnsupportedDecoratorType;
/**
 *
 * @param target
 * @param {string} propertyKey
 * @returns {DecoratorParameters}
 */
function decoratorArgs(target, propertyKey) {
    return [target, propertyKey, ObjectUtils_1.descriptorOf(target, propertyKey)];
}
exports.decoratorArgs = decoratorArgs;
function decorateMethodsOf(klass, decorator) {
    ObjectUtils_1.methodsOf(klass).forEach(({ target, propertyKey }) => {
        if (target !== ObjectUtils_1.classOf(klass)) {
            Object.defineProperty(ObjectUtils_1.prototypeOf(klass), propertyKey, {
                value(...args) {
                    return ObjectUtils_1.prototypeOf(target)[propertyKey].apply(this, args);
                }
            });
        }
        decorator(ObjectUtils_1.prototypeOf(klass), propertyKey, ObjectUtils_1.descriptorOf(klass, propertyKey));
    });
}
exports.decorateMethodsOf = decorateMethodsOf;
function applyDecorators(...decorators) {
    return (...args) => {
        decorators
            .filter((o) => !!o)
            .forEach((decorator) => {
            decorator(...args);
        });
    };
}
exports.applyDecorators = applyDecorators;
function useDecorators(...decorators) {
    return applyDecorators(...decorators);
}
exports.useDecorators = useDecorators;
function useMethodDecorator(decorator) {
    return (target, propertyKey) => decorator(target, propertyKey, ObjectUtils_1.descriptorOf(target, propertyKey));
}
exports.useMethodDecorator = useMethodDecorator;
function useMethodDecorators(...decorators) {
    return (target, propertyKey) => {
        decorators.filter(Boolean).forEach((decorator) => decorator(target, propertyKey, ObjectUtils_1.descriptorOf(target, propertyKey)));
    };
}
exports.useMethodDecorators = useMethodDecorators;
//# sourceMappingURL=DecoratorUtils.js.map