"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serialize = exports.classToPlainObject = void 0;
const core_1 = require("@tsed/core");
const schema_1 = require("@tsed/schema");
require("../components");
const JsonMapperContext_1 = require("../domain/JsonMapperContext");
const JsonMapperTypesContainer_1 = require("../domain/JsonMapperTypesContainer");
function alterValue(schema, value, options) {
    return schema.$hooks.alter("onSerialize", value, [options]);
}
function getSchemaProperties(storedJson, obj) {
    const stores = Array.from(schema_1.getPropertiesStores(storedJson).entries());
    if (!stores.length) {
        // fallback to auto discovering field from obj
        core_1.objectKeys(obj).forEach((key) => {
            const propStore = schema_1.JsonEntityStore.from(core_1.classOf(storedJson.target), key);
            stores.push([key, propStore]);
        });
    }
    return stores;
}
function getObjectProperties(obj) {
    return Object.entries(obj).filter(([, value]) => !core_1.isFunction(value));
}
function getType(propStore, value) {
    if (core_1.isNil(value) || propStore.type === Object || core_1.isCollection(propStore.type)) {
        return undefined;
    }
    return propStore.type;
}
function classToPlainObject(obj, options) {
    const { useAlias = true, type, ...props } = options;
    const entity = schema_1.JsonEntityStore.from(type || obj);
    return getSchemaProperties(entity, obj).reduce((newObj, [key, propStore]) => {
        const schema = propStore.schema;
        if (schema_1.alterIgnore(schema, { useAlias, ...props, self: obj })) {
            return newObj;
        }
        let value = alterValue(schema, obj[key], { useAlias, ...props, self: obj });
        value = serialize(value, {
            useAlias,
            type: value === obj[key] ? getType(propStore, value) : undefined,
            collectionType: propStore.collectionType,
            ...props
        });
        if (value === undefined) {
            return newObj;
        }
        key = useAlias ? propStore.parent.schema.getAliasOf(key) || key : key;
        return {
            ...newObj,
            [key]: value
        };
    }, {});
}
exports.classToPlainObject = classToPlainObject;
function toObject(obj, options) {
    return getObjectProperties(obj).reduce((newObj, [key, value]) => ({
        ...newObj,
        [key]: serialize(value, options)
    }), {});
}
function serialize(obj, { type, collectionType, ...options } = {}) {
    const types = options.types ? options.types : JsonMapperTypesContainer_1.getJsonMapperTypes();
    // prevent Object metadata assignation. TypeScript set Object by default on endpoint.type
    type = type === Object ? undefined : type;
    if (core_1.isEmpty(obj)) {
        return obj;
    }
    if (obj.$toObject) {
        // mongoose
        return serialize(obj.$toObject(options, true), { type: type || obj.$getTarget(), collectionType, ...options });
    }
    if (type && core_1.isClass(type)) {
        options.type = type;
    }
    if (core_1.isCollection(obj) && !options.collectionType) {
        type = core_1.classOf(obj);
        options.collectionType = type;
    }
    type = core_1.classOf(type || obj);
    const context = new JsonMapperContext_1.JsonMapperContext({
        type,
        options,
        next: (data) => serialize(data, {
            ...options,
            collectionType: undefined,
            type: options.type
        })
    });
    if (types.has(type)) {
        const jsonMapper = types.get(type);
        return jsonMapper.serialize(obj, context);
    }
    if (typeof obj.toJSON === "function") {
        // serialize from serialize method
        return obj.toJSON(context);
    }
    if (typeof obj.serialize === "function") {
        // serialize from serialize method
        return obj.serialize(context);
    }
    return !core_1.isPlainObject(type) ? classToPlainObject(obj, options) : toObject(obj, options);
}
exports.serialize = serialize;
//# sourceMappingURL=serialize.js.map