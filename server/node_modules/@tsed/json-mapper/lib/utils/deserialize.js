"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserialize = exports.plainObjectToClass = void 0;
const core_1 = require("@tsed/core");
const schema_1 = require("@tsed/schema");
require("../components");
const JsonMapperContext_1 = require("../domain/JsonMapperContext");
const JsonMapperTypesContainer_1 = require("../domain/JsonMapperTypesContainer");
function isDeserializable(obj, options) {
    if ((!!options.collectionType && core_1.isNil(obj)) || obj === undefined) {
        return false;
    }
    return !(core_1.isEmpty(options.type) || (options.type === Object && !options.collectionType));
}
function alterValue(schema, value, options) {
    return schema.$hooks.alter("onDeserialize", value, [options]);
}
function transformCollection(src, options) {
    var _a;
    const { types, type = Object, collectionType } = options;
    const context = new JsonMapperContext_1.JsonMapperContext({
        type,
        collectionType,
        options,
        next: (data, { collectionType, ...options }) => deserialize(data, options)
    });
    return (_a = types === null || types === void 0 ? void 0 : types.get(options.collectionType)) === null || _a === void 0 ? void 0 : _a.deserialize(src, context);
}
function transformType(src, options) {
    var _a;
    const { types, type = Object } = options;
    const context = new JsonMapperContext_1.JsonMapperContext({
        type,
        options,
        next: (data, { type, ...options }) => deserialize(data, options)
    });
    return (_a = types === null || types === void 0 ? void 0 : types.get(type)) === null || _a === void 0 ? void 0 : _a.deserialize(src, context);
}
/**
 * Transform given plain object to class.
 * @param src
 * @param options
 */
function plainObjectToClass(src, options) {
    if (core_1.isEmpty(src)) {
        return src;
    }
    const { type, store = schema_1.JsonEntityStore.from(type), ...next } = options;
    const propertiesMap = schema_1.getPropertiesStores(store);
    let keys = core_1.objectKeys(src);
    const additionalProperties = propertiesMap.size ? !!store.schema.get("additionalProperties") || options.additionalProperties : true;
    const out = new type(src);
    propertiesMap.forEach((propStore) => {
        const key = propStore.parent.schema.getAliasOf(propStore.propertyName) || propStore.propertyName;
        keys = keys.filter((k) => k !== key);
        let value = alterValue(propStore.schema, src[key], { ...options, self: src });
        next.type = propStore.computedType;
        if (propStore.schema.hasGenerics) {
            next.nestedGenerics = propStore.schema.nestedGenerics;
        }
        else if (propStore.schema.isGeneric && options.nestedGenerics) {
            const [genericTypes = [], ...nestedGenerics] = options.nestedGenerics;
            const genericLabels = propStore.parent.schema.genericLabels || [];
            next.type = genericTypes[genericLabels.indexOf(propStore.schema.genericType)] || Object;
            next.nestedGenerics = nestedGenerics;
        }
        value = deserialize(value, {
            ...next,
            collectionType: propStore.collectionType
        });
        if (value !== undefined) {
            out[propStore.propertyName] = value;
        }
    });
    if (additionalProperties) {
        keys.forEach((key) => {
            out[key] = src[key];
        });
    }
    return out;
}
exports.plainObjectToClass = plainObjectToClass;
function buildOptions(options) {
    if (options.store instanceof schema_1.JsonEntityStore) {
        if (options.store.parameter && options.store.parameter.nestedGenerics.length) {
            options.nestedGenerics = options.store.parameter.nestedGenerics;
        }
        options.type = options.store.computedType;
        options.collectionType = options.store.collectionType;
        delete options.store;
    }
    return {
        ...options,
        types: options.types ? options.types : JsonMapperTypesContainer_1.getJsonMapperTypes()
    };
}
/**
 * Transform given source to class base on the given `options.type`.
 *
 * @param src
 * @param options
 */
function deserialize(src, options = {}) {
    var _a, _b;
    options = buildOptions(options);
    if (!isDeserializable(src, options)) {
        return src;
    }
    if (!options.collectionType && core_1.isArray(src)) {
        options.collectionType = Array;
    }
    if (options.collectionType) {
        if (!((_a = options.types) === null || _a === void 0 ? void 0 : _a.has(options.collectionType))) {
            throw new Error(`${core_1.nameOf(options.collectionType)} is not supported by JsonMapper.`);
        }
        return transformCollection(src, options);
    }
    if ((_b = options.types) === null || _b === void 0 ? void 0 : _b.has(options.type)) {
        return transformType(src, options);
    }
    // class converter
    return plainObjectToClass(src, options);
}
exports.deserialize = deserialize;
//# sourceMappingURL=deserialize.js.map