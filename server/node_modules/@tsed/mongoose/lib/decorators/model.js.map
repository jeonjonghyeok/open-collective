{"version":3,"file":"model.js","sourceRoot":"","sources":["../../src/decorators/model.ts"],"names":[],"mappings":";;;AAAA,qCAAyC;AACzC,4CAAiD;AAEjD,+EAAkE;AAClE,yEAAqE;AACrE,oCAAgD;AAChD,0DAAyE;AAEzE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAoCG;AACH,SAAgB,KAAK,CAAC,UAAgC,EAAE;IACtD,OAAO,CAAC,MAAW,EAAE,EAAE;QACrB,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,IAAI,aAAM,CAAC,MAAM,CAAC,CAAC;QAC5C,YAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,+BAAmB,EAAE,IAAI,CAAC,CAAC;QAElD,MAAM,MAAM,GAAG,iBAAS,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QAE1C,qCAAa,CAAC;YACZ,OAAO,EAAE,MAAM;YACf,IAAI,EAAE,CAAC,0CAAoB,CAAC;YAC5B,UAAU,CAAC,WAAiC;gBAC1C,kCAAkB,CAAC,MAAM,EAAE,6BAAa,CAAC,MAAM,CAAC,CAAC,CAAC;gBAElD,MAAM,KAAK,GAAG,mBAAW,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,UAAU,EAAE,OAAO,CAAC,QAAQ,EAAE,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC;gBAClI,KAAa,CAAC,SAAS,CAAC,UAAU,GAAG,GAAG,EAAE,CAAC,MAAM,CAAC;gBAEnD,OAAO,KAAK,CAAC;YACf,CAAC;SACF,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC;AApBD,sBAoBC","sourcesContent":["import {nameOf, Store} from \"@tsed/core\";\nimport {MONGOOSE_MODEL_NAME} from \"../constants\";\nimport {MongooseModelOptions} from \"../interfaces/MongooseModelOptions\";\nimport {registerModel} from \"../registries/MongooseModelRegistry\";\nimport {MONGOOSE_CONNECTIONS} from \"../services/MongooseConnections\";\nimport {createModel, getSchema} from \"../utils\";\nimport {applySchemaOptions, schemaOptions} from \"../utils/schemaOptions\";\n\n/**\n * Define a class as a Mongoose Model. The model can be injected to the Service, Controller, Middleware, Converters or Filter with\n * `@Inject` annotation.\n *\n * ### Example\n *\n * ```typescript\n * @Model()\n * export class EventModel {\n *   @Property()\n *   field: string;\n * }\n * ```\n *\n * Then inject the model into a service:\n *\n * ```typescript\n * class MyService {\n *    constructor(@Inject(EventModel) eventModel: MongooseModel<EventModel>) {\n *        eventModel.findById().exec();\n *    }\n * }\n * ```\n *\n * ### Options\n *\n * - `schemaOptions` (mongoose.SchemaOptions): Option to configure the schema behavior.\n * - `name` (String): model name.\n * - `collection` (String): collection (optional, induced from model name).\n * - `skipInit` (Boolean): skipInit whether to skip initialization (defaults to false).\n *\n * @param {MongooseModelOptions} options\n * @returns {(target: any) => void}\n * @decorator\n * @mongoose\n * @class\n */\nexport function Model(options: MongooseModelOptions = {}) {\n  return (target: any) => {\n    const name = options.name || nameOf(target);\n    Store.from(target).set(MONGOOSE_MODEL_NAME, name);\n\n    const schema = getSchema(target, options);\n\n    registerModel({\n      provide: target,\n      deps: [MONGOOSE_CONNECTIONS],\n      useFactory(connections: MONGOOSE_CONNECTIONS) {\n        applySchemaOptions(schema, schemaOptions(target));\n\n        const model = createModel(target, schema, options.name, options.collection, options.skipInit, connections.get(options.connection));\n        (model as any).prototype.$getTarget = () => target;\n\n        return model;\n      }\n    });\n  };\n}\n"]}