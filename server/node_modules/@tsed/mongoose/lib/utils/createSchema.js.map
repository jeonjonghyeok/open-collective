{"version":3,"file":"createSchema.js","sourceRoot":"","sources":["../../src/utils/createSchema.ts"],"names":[],"mappings":";;;AAAA,qCAAoD;AACpD,yCAA4D;AAC5D,qCAAqC;AAErC,4CAA6C;AAE7C,qDAAgD;AAChD,mDAA8C;AAE9C,MAAM,sBAAsB,GAAG,CAAC,KAAK,CAAC,CAAC;AAOvC;;GAEG;AACH,SAAS,WAAW,CAAC,EAAC,MAAM,EAAE,QAAQ,EAAyB,EAAE,OAAgC;IAC/F,MAAM,cAAc,GAAG,IAAI,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAE5D,KAAK,MAAM,CAAC,GAAG,EAAE,OAAO,CAAC,IAAI,QAAQ,CAAC,OAAO,EAAE,EAAE;QAC/C,cAAc,CAAC,OAAO,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;KACtC;IAED,OAAO,cAAc,CAAC;AACxB,CAAC;AAED;;GAEG;AACH,SAAS,YAAY,CAAC,OAA4B;IAChD,OAAO,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,YAAY,CAAC;AACnE,CAAC;AAED,SAAgB,YAAY,CAAC,MAAiB,EAAE,UAAiC,EAAE;IACjF,MAAM,MAAM,GAAG,WAAW,CAAC,mBAAmB,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC,aAAa,CAAC,CAAC;IAE/E,6BAAa,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAC/B,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;IAEzB,OAAO,MAAM,CAAC;AAChB,CAAC;AAPD,oCAOC;AAED;;;;GAIG;AACH,SAAgB,SAAS,CAAC,MAAiB,EAAE,UAAiC,EAAE;IAC9E,MAAM,KAAK,GAAG,YAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAEjC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,2BAAe,CAAC,EAAE;QAC/B,KAAK,CAAC,GAAG,CAAC,2BAAe,EAAE,YAAY,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;KAC3D;IAED,OAAO,KAAK,CAAC,GAAG,CAAC,2BAAe,CAAC,CAAC;AACpC,CAAC;AARD,8BAQC;AAED;;GAEG;AACH,SAAgB,mBAAmB,CAAC,MAAW;IAC7C,MAAM,UAAU,GAAG,sBAAa,CAAC,MAAM,EAAE,EAAC,gBAAgB,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAC,CAAC,CAAC;IACnF,MAAM,MAAM,GAA2B,EAAC,MAAM,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,GAAG,EAAE,EAAC,CAAC;IAEzE,UAAU,CAAC,OAAO,CAAC,CAAC,gBAAgB,EAAE,GAAG,EAAE,EAAE;QAC3C,IAAI,sBAAsB,CAAC,QAAQ,CAAC,GAAa,CAAC,EAAE;YAClD,OAAO;SACR;QAED,kGAAkG;QAClG,MAAM,iBAAiB,GAAG,gBAAgB,CAAC,KAAK,CAAC,GAAG,CAAC,2BAAe,CAAC,IAAI,EAAE,CAAC;QAE5E,IAAI,iBAAiB,CAAC,YAAY,EAAE;YAClC,OAAO;SACR;QAED,IAAI,YAAY,CAAC,iBAAiB,CAAC,EAAE;YACnC,iBAAiB,CAAC,GAAG,GAAG,+BAAc,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC;YAE9D,iBAAiB,CAAC,OAAO,GAAG,CAAC,gBAAgB,CAAC,OAAO,CAAC;YACtD,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAa,EAAE,iBAAiB,CAAC,CAAC;YAEtD,OAAO;SACR;QAED,MAAM,CAAC,MAAM,CAAC,GAAa,CAAC,GAAG,uBAAuB,CAAC,gBAAgB,CAAC,CAAC;IAC3E,CAAC,CAAC,CAAC;IAEH,OAAO,MAAM,CAAC;AAChB,CAAC;AA7BD,kDA6BC;AAED;;GAEG;AACH,SAAgB,uBAAuB,CAAC,UAA2B;IACjE,MAAM,GAAG,GAAG,UAAU,CAAC,WAAW,CAAC;IACnC,MAAM,iBAAiB,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,2BAAe,CAAC,IAAI,EAAE,CAAC;IAEtE,IAAI,iBAAiB,GAAwB;QAC3C,QAAQ,EAAE,UAAU,CAAC,QAAQ;YAC3B,CAAC,CAAC;gBACE,OAAO,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;YAC1C,CAAC;YACH,CAAC,CAAC,KAAK;KACV,CAAC;IAEF,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE;QACvB,MAAM,UAAU,GAAG,UAAU,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;QAClD,MAAM,EAAC,OAAO,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAC,GAAG,UAAU,CAAC;QAE5F,IAAI,KAAK,GAAoB,UAAU,CAAC,OAAO,CAAC;QAChD,IAAI,KAAK,EAAE;YACT,KAAK,GAAG,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC;SAC3B;QAED,iBAAiB,GAAG;YAClB,GAAG,iBAAiB;YACpB,IAAI,EAAE,UAAU,CAAC,IAAI;YACrB,KAAK;YACL,GAAG;YACH,GAAG;YACH,SAAS;YACT,SAAS;YACT,IAAI,EAAE,UAAU,CAAC,MAAM,CAAC;YACxB,OAAO,EAAE,UAAU,CAAC,SAAS,CAAC;SAC/B,CAAC;KACH;SAAM,IAAI,CAAC,iBAAiB,CAAC,GAAG,EAAE;QACjC,4CAA4C;QAC5C,iBAAiB,GAAG,EAAC,GAAG,iBAAiB,EAAE,IAAI,EAAE,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,EAAC,CAAC;KAC9E;IAED,iBAAiB,GAAG,kBAAW,CAAC,EAAC,GAAG,iBAAiB,EAAE,GAAG,iBAAiB,EAAC,CAAC,CAAC;IAE9E,IAAI,UAAU,CAAC,YAAY,EAAE;QAC3B,IAAI,UAAU,CAAC,OAAO,EAAE;YACtB,iBAAiB,GAAG,CAAC,iBAAiB,CAAC,CAAC;SACzC;aAAM;YACL,yBAAyB;YACzB,gCAAgC;YAChC,IAAI,UAAU,CAAC,cAAc,KAAK,GAAG,EAAE;gBACrC,MAAM,IAAI,KAAK,CAAC,4BAA4B,UAAU,CAAC,cAAc,oBAAoB,CAAC,CAAC;aAC5F;YAED,iBAAiB,GAAG,EAAC,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,iBAAiB,EAAC,CAAC;SACxD;KACF;IAED,OAAO,iBAAiB,CAAC;AAC3B,CAAC;AAtDD,0DAsDC","sourcesContent":["import {cleanObject, Store, Type} from \"@tsed/core\";\nimport {JsonEntityStore, getProperties} from \"@tsed/schema\";\nimport * as mongoose from \"mongoose\";\nimport {SchemaDefinition, SchemaTypeOpts} from \"mongoose\";\nimport {MONGOOSE_SCHEMA} from \"../constants\";\nimport {MongooseSchemaOptions} from \"../interfaces\";\nimport {resolveRefType} from \"./resolveRefType\";\nimport {schemaOptions} from \"./schemaOptions\";\n\nconst MONGOOSE_RESERVED_KEYS = [\"_id\"];\n\nexport interface MongooseSchemaMetadata {\n  schema: SchemaDefinition;\n  virtuals: Map<string, any>;\n}\n\n/**\n * @ignore\n */\nfunction setUpSchema({schema, virtuals}: MongooseSchemaMetadata, options?: mongoose.SchemaOptions) {\n  const mongooseSchema = new mongoose.Schema(schema, options);\n\n  for (const [key, options] of virtuals.entries()) {\n    mongooseSchema.virtual(key, options);\n  }\n\n  return mongooseSchema;\n}\n\n/**\n * @ignore\n */\nfunction isVirtualRef(options: SchemaTypeOpts<any>) {\n  return options.ref && options.localField && options.foreignField;\n}\n\nexport function createSchema(target: Type<any>, options: MongooseSchemaOptions = {}): mongoose.Schema {\n  const schema = setUpSchema(buildMongooseSchema(target), options.schemaOptions);\n\n  schemaOptions(target, options);\n  schema.loadClass(target);\n\n  return schema;\n}\n\n/**\n * Get a schema already created. If the schema doesn't exists in registry, it'll be created.\n * @param target\n * @param options\n */\nexport function getSchema(target: Type<any>, options: MongooseSchemaOptions = {}): mongoose.Schema {\n  const store = Store.from(target);\n\n  if (!store.has(MONGOOSE_SCHEMA)) {\n    store.set(MONGOOSE_SCHEMA, createSchema(target, options));\n  }\n\n  return store.get(MONGOOSE_SCHEMA);\n}\n\n/**\n * @ignore\n */\nexport function buildMongooseSchema(target: any): MongooseSchemaMetadata {\n  const properties = getProperties(target, {withIgnoredProps: true, mongoose: true});\n  const schema: MongooseSchemaMetadata = {schema: {}, virtuals: new Map()};\n\n  properties.forEach((propertyMetadata, key) => {\n    if (MONGOOSE_RESERVED_KEYS.includes(key as string)) {\n      return;\n    }\n\n    // Keeping the Mongoose Schema separate so it can overwrite everything once schema has been built.\n    const schemaTypeOptions = propertyMetadata.store.get(MONGOOSE_SCHEMA) || {};\n\n    if (schemaTypeOptions.schemaIgnore) {\n      return;\n    }\n\n    if (isVirtualRef(schemaTypeOptions)) {\n      schemaTypeOptions.ref = resolveRefType(schemaTypeOptions.ref);\n\n      schemaTypeOptions.justOne = !propertyMetadata.isArray;\n      schema.virtuals.set(key as string, schemaTypeOptions);\n\n      return;\n    }\n\n    schema.schema[key as string] = createSchemaTypeOptions(propertyMetadata);\n  });\n\n  return schema;\n}\n\n/**\n * @ignore\n */\nexport function createSchemaTypeOptions(propEntity: JsonEntityStore): SchemaTypeOpts<any> {\n  const key = propEntity.propertyKey;\n  const rawMongooseSchema = propEntity.store.get(MONGOOSE_SCHEMA) || {};\n\n  let schemaTypeOptions: SchemaTypeOpts<any> = {\n    required: propEntity.required\n      ? function () {\n          return propEntity.isRequired(this[key]);\n        }\n      : false\n  };\n\n  if (!propEntity.isClass) {\n    const jsonSchema = propEntity.itemSchema.toJSON();\n    const {minimum: min, maximum: max, minLength: minlength, maxLength: maxlength} = jsonSchema;\n\n    let match: string | RegExp = jsonSchema.pattern;\n    if (match) {\n      match = new RegExp(match);\n    }\n\n    schemaTypeOptions = {\n      ...schemaTypeOptions,\n      type: propEntity.type,\n      match,\n      min,\n      max,\n      minlength,\n      maxlength,\n      enum: jsonSchema[\"enum\"],\n      default: jsonSchema[\"default\"]\n    };\n  } else if (!rawMongooseSchema.ref) {\n    // References are handled by the final merge\n    schemaTypeOptions = {...schemaTypeOptions, type: getSchema(propEntity.type)};\n  }\n\n  schemaTypeOptions = cleanObject({...schemaTypeOptions, ...rawMongooseSchema});\n\n  if (propEntity.isCollection) {\n    if (propEntity.isArray) {\n      schemaTypeOptions = [schemaTypeOptions];\n    } else {\n      // Can be a Map or a Set;\n      // Mongoose implements only Map;\n      if (propEntity.collectionType !== Map) {\n        throw new Error(`Invalid collection type. ${propEntity.collectionName} is not supported.`);\n      }\n\n      schemaTypeOptions = {type: Map, of: schemaTypeOptions};\n    }\n  }\n\n  return schemaTypeOptions;\n}\n"]}