{"version":3,"file":"JsonSchema.js","sourceRoot":"","sources":["../../src/domain/JsonSchema.ts"],"names":[],"mappings":"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","sourcesContent":["import {classOf, Hooks, isArray, isClass, isFunction, nameOf, Type, uniq, ValueOf} from \"@tsed/core\";\nimport {JSONSchema6, JSONSchema6Definition, JSONSchema6Type, JSONSchema6TypeName, JSONSchema6Version} from \"json-schema\";\nimport {JsonSchemaOptions} from \"../interfaces\";\nimport {IgnoreCallback} from \"../interfaces/IgnoreCallback\";\nimport {NestedGenerics} from \"../utils/generics\";\nimport {getComputedType} from \"../utils/getComputedType\";\nimport {getJsonType} from \"../utils/getJsonType\";\nimport {serializeJsonSchema} from \"../utils/serializeJsonSchema\";\nimport {toJsonRegex} from \"../utils/toJsonRegex\";\nimport {AliasMap, AliasType} from \"./JsonAliasMap\";\nimport {JsonFormatTypes} from \"./JsonFormatTypes\";\n\nexport interface JsonSchemaObject extends JSONSchema6 {\n  type: (any | JSONSchema6TypeName) | (any | JSONSchema6TypeName)[];\n  additionalProperties?: boolean | JSONSchema6 | any;\n  propertyNames?: boolean | JSONSchema6 | any;\n  items?: (any | JSONSchema6Definition) | (any | JSONSchema6Definition)[];\n}\n\nfunction mapToJsonSchema(item: any): any {\n  if (typeof item !== \"object\") {\n    return item;\n  }\n\n  if (isArray(item)) {\n    return (item as any[]).map(mapToJsonSchema);\n  }\n\n  return item instanceof JsonSchema ? item : JsonSchema.from(item as any);\n}\n\nfunction mapProperties(properties: {[p: string]: any}) {\n  // istanbul ignore next\n  if (properties instanceof JsonSchema) {\n    return properties;\n  }\n\n  return Object.entries(properties).reduce<any>((properties, [key, schema]) => {\n    properties[toJsonRegex(key)] = isArray(schema) ? schema.map(mapToJsonSchema) : mapToJsonSchema(schema);\n\n    return properties;\n  }, {});\n}\n\nexport class JsonSchema extends Map<string, any> implements NestedGenerics {\n  readonly $hooks = new Hooks();\n  readonly $required: Set<string> = new Set();\n  public $selfRequired: boolean;\n  protected _genericLabels: string[];\n  protected _nestedGenerics: Type<any>[][] = [];\n  protected _alias: AliasMap = new Map();\n  protected _itemSchema: JsonSchema;\n  protected _target: Type<any>;\n  protected _isGeneric: boolean = false;\n  protected _isCollection: boolean = false;\n  protected _ref: boolean = false;\n\n  constructor(obj: JsonSchema | Partial<JsonSchemaObject> = {}) {\n    super();\n\n    if (obj) {\n      this.assign(obj);\n    }\n  }\n\n  get alias() {\n    return this._alias;\n  }\n\n  get nestedGenerics(): any[] {\n    return this._nestedGenerics;\n  }\n\n  set nestedGenerics(value: any[]) {\n    this._nestedGenerics = value;\n  }\n\n  get genericLabels(): string[] {\n    return this._genericLabels;\n  }\n\n  set genericLabels(value: string[]) {\n    this._genericLabels = value;\n  }\n\n  get isClass() {\n    return isClass(this.class) && ![Map, Array, Set, Object, Date, Boolean, Number, String].includes(this._target as any);\n  }\n\n  /**\n   * Current schema is a collection\n   */\n  get isCollection() {\n    return this._isCollection;\n  }\n\n  /**\n   * Current schema is a generic\n   */\n  get isGeneric() {\n    return this._isGeneric;\n  }\n\n  /**\n   * Current schema has generics items\n   */\n  get hasGenerics(): boolean {\n    return !!(this.nestedGenerics && this.nestedGenerics.length);\n  }\n\n  get genericType(): string {\n    return this.get(\"$ref\");\n  }\n\n  get class() {\n    return this.getComputedType();\n  }\n\n  get canRef(): boolean {\n    return this._ref;\n  }\n\n  static from(obj: Partial<JsonSchemaObject> = {}) {\n    return new JsonSchema(obj);\n  }\n\n  itemSchema(obj: JsonSchemaObject | JsonSchema | any = {}) {\n    this._itemSchema = this._itemSchema || mapToJsonSchema(obj);\n    this._itemSchema.assign(obj);\n\n    return this._itemSchema;\n  }\n\n  getAliasOf(property: AliasType) {\n    return this._alias.get(property as any);\n  }\n\n  addAlias(property: AliasType, alias: AliasType) {\n    this._alias.set(property, alias);\n    this._alias.set(alias, property);\n\n    return this;\n  }\n\n  removeAlias(property: AliasType) {\n    const alias = this._alias.get(property);\n    alias && this._alias.delete(alias);\n    this._alias.delete(property);\n\n    return this;\n  }\n\n  $id($id: string) {\n    super.set(\"$id\", $id);\n\n    return this;\n  }\n\n  $ref($ref: string) {\n    super.set(\"$ref\", $ref);\n\n    return this;\n  }\n\n  $schema($schema: JSONSchema6Version) {\n    super.set(\"$schema\", $schema);\n\n    return this;\n  }\n\n  /**\n   * Create a ref and use name to sharing schema\n   * @param name\n   */\n  label(name: string) {\n    this._ref = true;\n\n    super.set(\"name\", name);\n\n    return this;\n  }\n\n  name(name: string) {\n    super.set(\"name\", name);\n\n    return this;\n  }\n\n  ignore(cb: boolean | IgnoreCallback) {\n    if (typeof cb === \"boolean\") {\n      const bool = cb;\n      cb = () => bool;\n    }\n\n    this.$hooks.on(\"ignore\", cb);\n\n    return this;\n  }\n\n  /**\n   * This keyword can be used to supply a default JSON value associated with a particular schema.\n   * It is RECOMMENDED that a default value be valid against the associated schema.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.3\n   */\n  default(value: JSONSchema6Type) {\n    super.set(\"default\", value);\n\n    return this;\n  }\n\n  /**\n   * More readible form of a one-element \"enum\"\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.24\n   */\n  const(value: JSONSchema6Type) {\n    super.set(\"const\", value);\n\n    return this;\n  }\n\n  /**\n   * This attribute is a string that provides a full description of the of purpose the instance property.\n   *\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.2\n   */\n  description(description: string) {\n    super.set(\"description\", description);\n\n    return this;\n  }\n\n  /**\n   * This keyword determines how child instances validate for arrays, and does not directly validate the immediate instance itself.\n   * If \"items\" is an array of schemas, validation succeeds if every instance element\n   * at a position greater than the size of \"items\" validates against \"additionalItems\".\n   * Otherwise, \"additionalItems\" MUST be ignored, as the \"items\" schema\n   * (possibly the default value of an empty schema) is applied to all elements.\n   * Omitting this keyword has the same behavior as an empty schema.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.10\n   */\n  additionalItems(additionalItems: boolean | JsonSchemaObject) {\n    super.set(\"additionalItems\", mapToJsonSchema(additionalItems));\n\n    return this;\n  }\n\n  /**\n   * An array instance is valid against \"contains\" if at least one of its elements is valid against the given schema.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.14\n   */\n  contains(contains: JSONSchema6Definition) {\n    super.set(\"contains\", mapToJsonSchema(contains));\n\n    return this;\n  }\n\n  /**\n   * Array of examples with no validation effect the value of \"default\" is usable as an example without repeating it under this keyword\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.4\n   */\n  examples(examples: JSONSchema6Type[]) {\n    super.set(\"examples\", examples);\n\n    return this;\n  }\n\n  example(...examples: JSONSchema6Type[]) {\n    return this.examples(examples);\n  }\n\n  /**\n   * This keyword determines how child instances validate for arrays, and does not directly validate the immediate instance itself.\n   * Omitting this keyword has the same behavior as an empty schema.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.9\n   */\n  items(items: JsonSchema | JsonSchemaObject | (JsonSchemaObject | JsonSchema)[]) {\n    super.set(\"items\", (this._itemSchema = mapToJsonSchema(items)));\n\n    return this;\n  }\n\n  /**\n   * Must be a non-negative integer.\n   * An array instance is valid against \"maxItems\" if its size is less than, or equal to, the value of this keyword.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.11\n   */\n  maxItems(maxItems: number) {\n    super.set(\"maxItems\", maxItems);\n\n    return this;\n  }\n\n  /**\n   * Must be a non-negative integer.\n   * An array instance is valid against \"maxItems\" if its size is greater than, or equal to, the value of this keyword.\n   * Omitting this keyword has the same behavior as a value of 0.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.12\n   */\n  minItems(minItems: number) {\n    super.set(\"minItems\", minItems);\n\n    return this;\n  }\n\n  /**\n   * If this keyword has boolean value false, the instance validates successfully.\n   * If it has boolean value true, the instance validates successfully if all of its elements are unique.\n   * Omitting this keyword has the same behavior as a value of false.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.13\n   */\n  uniqueItems(uniqueItems: boolean) {\n    super.set(\"uniqueItems\", uniqueItems);\n\n    return this;\n  }\n\n  /**\n   * Must be a non-negative integer.\n   * An object instance is valid against \"maxProperties\" if its number of properties is less than, or equal to, the value of this keyword.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.15\n   */\n  maxProperties(maxProperties: number) {\n    super.set(\"maxProperties\", maxProperties);\n\n    return this;\n  }\n\n  /**\n   * Must be a non-negative integer.\n   * An object instance is valid against \"maxProperties\" if its number of properties is greater than,\n   * or equal to, the value of this keyword.\n   * Omitting this keyword has the same behavior as a value of 0.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.16\n   */\n  minProperties(minProperties: number) {\n    super.set(\"minProperties\", minProperties);\n\n    return this;\n  }\n\n  /**\n   * Elements of this array must be unique.\n   * An object instance is valid against this keyword if every item in the array is the name of a property in the instance.\n   * Omitting this keyword has the same behavior as an empty array.\n   *\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.17\n   */\n  required(required: boolean | string[] = true) {\n    if (isArray(required)) {\n      this.$required.clear();\n\n      required.forEach((value: any) => this.$required.add(value));\n    } else {\n      const schema = this.clone();\n      schema.$selfRequired = required;\n      return schema;\n    }\n\n    return this;\n  }\n\n  addRequired(property: string) {\n    this.$required.add(property);\n\n    return this;\n  }\n\n  removeRequired(property: string) {\n    this.$required.delete(property);\n\n    return this;\n  }\n\n  isRequired(property: string): boolean {\n    return this.$required.has(property);\n  }\n\n  /**\n   * This keyword determines how child instances validate for objects, and does not directly validate the immediate instance itself.\n   * Validation succeeds if, for each name that appears in both the instance and as a name within this keyword's value,\n   * the child instance for that name successfully validates against the corresponding schema.\n   * Omitting this keyword has the same behavior as an empty object.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.18\n   */\n  properties(properties: JsonSchema | {[key: string]: JsonSchemaObject | JsonSchema}) {\n    super.set(\"properties\", mapProperties(properties));\n\n    return this;\n  }\n\n  addProperty(key: string, schema: JsonSchemaObject | JsonSchema) {\n    const properties = this.get(\"properties\") || {};\n\n    properties[key] = schema;\n\n    super.set(\"properties\", mapProperties(properties));\n\n    return this;\n  }\n\n  /**\n   * This attribute is an object that defines the schema for a set of property names of an object instance.\n   * The name of each property of this attribute's object is a regular expression pattern in the ECMA 262, while the value is a schema.\n   * If the pattern matches the name of a property on the instance object, the value of the instance's property\n   * MUST be valid against the pattern name's schema value.\n   * Omitting this keyword has the same behavior as an empty object.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.19\n   */\n  patternProperties(patternProperties: {[p: string]: JsonSchemaObject | JsonSchema}) {\n    super.set(\"patternProperties\", mapProperties(patternProperties));\n\n    return this;\n  }\n\n  /**\n   * This attribute defines a schema for all properties that are not explicitly defined in an object type definition.\n   * If specified, the value MUST be a schema or a boolean.\n   * If false is provided, no additional properties are allowed beyond the properties defined in the schema.\n   * The default value is an empty schema which allows any value for additional properties.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.20\n   */\n  additionalProperties(additionalProperties: boolean | JsonSchemaObject | JsonSchema) {\n    super.set(\"additionalProperties\", mapToJsonSchema(additionalProperties));\n\n    return this;\n  }\n\n  /**\n   * This attribute defines a schema for all properties that are not explicitly defined in an object type definition.\n   * If specified, the value MUST be a schema or a boolean.\n   * If false is provided, no additional properties are allowed beyond the properties defined in the schema.\n   * The default value is an empty schema which allows any value for additional properties.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.20\n   * @alias additionalProperties\n   * @param unknown\n   */\n  unknown(unknown: boolean = true) {\n    return this.additionalProperties(unknown);\n  }\n\n  /**\n   * This keyword specifies rules that are evaluated if the instance is an object and contains a certain property.\n   * Each property specifies a dependency.\n   * If the dependency value is an array, each element in the array must be unique.\n   * Omitting this keyword has the same behavior as an empty object.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.21\n   */\n  dependencies(dependencies: {[p: string]: JSONSchema6Definition | JsonSchema | string[]}) {\n    super.set(\"dependencies\", mapProperties(dependencies));\n\n    return this;\n  }\n\n  /**\n   * Takes a schema which validates the names of all properties rather than their values.\n   * Note the property name that the schema is testing will always be a string.\n   * Omitting this keyword has the same behavior as an empty schema.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.22\n   */\n  propertyNames(propertyNames: JSONSchema6Definition | JsonSchema) {\n    super.set(\"propertyNames\", mapToJsonSchema(propertyNames));\n\n    return this;\n  }\n\n  /**\n   * This provides an enumeration of all possible values that are valid\n   * for the instance property. This MUST be an array, and each item in\n   * the array represents a possible value for the instance value. If\n   * this attribute is defined, the instance value MUST be one of the\n   * values in the array in order for the schema to be valid.\n   *\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.23\n   */\n  enum(enumValues: JSONSchema6Type[]): this {\n    super.set(\"enum\", uniq(enumValues));\n\n    return this;\n  }\n\n  /**\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.1\n   */\n  definitions(definitions: {[p: string]: JsonSchemaObject | JsonSchema}) {\n    super.set(\"definitions\", mapProperties(definitions));\n\n    return this;\n  }\n\n  /**\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.26\n   */\n  allOf(allOf: (JsonSchemaObject | JsonSchema)[]) {\n    super.set(\"allOf\", allOf.map(mapToJsonSchema));\n\n    return this;\n  }\n\n  /**\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.27\n   */\n  anyOf(anyOf: (JsonSchemaObject | JsonSchema)[]) {\n    super.set(\"anyOf\", anyOf.map(mapToJsonSchema));\n\n    return this;\n  }\n\n  /**\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.28\n   */\n  oneOf(oneOf: (JsonSchemaObject | JsonSchema)[]) {\n    super.set(\"oneOf\", oneOf.map(mapToJsonSchema));\n\n    return this;\n  }\n\n  /**\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.29\n   */\n  not(not: JsonSchemaObject | JsonSchema) {\n    super.set(\"not\", mapToJsonSchema(not));\n\n    return this;\n  }\n\n  /**\n   * Must be strictly greater than 0.\n   * A numeric instance is valid only if division by this keyword's value results in an integer.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.1\n   */\n  multipleOf(multipleOf: number): this {\n    super.set(\"multipleOf\", multipleOf);\n\n    return this;\n  }\n\n  /**\n   * Representing an inclusive upper limit for a numeric instance.\n   * This keyword validates only if the instance is less than or exactly equal to \"maximum\".\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.2\n   */\n  maximum(maximum: number): this {\n    super.set(\"maximum\", maximum);\n\n    return this;\n  }\n\n  /**\n   * Representing an exclusive upper limit for a numeric instance.\n   * This keyword validates only if the instance is strictly less than (not equal to) to \"exclusiveMaximum\".\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.3\n   */\n  exclusiveMaximum(exclusiveMaximum: number): this {\n    super.set(\"exclusiveMaximum\", exclusiveMaximum);\n\n    return this;\n  }\n\n  /**\n   * Representing an inclusive lower limit for a numeric instance.\n   * This keyword validates only if the instance is greater than or exactly equal to \"minimum\".\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.4\n   */\n  minimum(minimum: number): this {\n    super.set(\"minimum\", minimum);\n\n    return this;\n  }\n\n  /**\n   * Representing an exclusive lower limit for a numeric instance.\n   * This keyword validates only if the instance is strictly greater than (not equal to) to \"exclusiveMinimum\".\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.5\n   */\n  exclusiveMinimum(exclusiveMinimum: number): this {\n    super.set(\"exclusiveMinimum\", exclusiveMinimum);\n\n    return this;\n  }\n\n  /**\n   * Must be a non-negative integer.\n   * A string instance is valid against this keyword if its length is less than, or equal to, the value of this keyword.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.6\n   */\n  maxLength(maxLength: number): this {\n    super.set(\"maxLength\", maxLength);\n\n    return this;\n  }\n\n  /**\n   * Must be a non-negative integer.\n   * A string instance is valid against this keyword if its length is greater than, or equal to, the value of this keyword.\n   * Omitting this keyword has the same behavior as a value of 0.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.7\n   */\n  minLength(minLength: number): this {\n    super.set(\"minLength\", minLength);\n\n    return this;\n  }\n\n  /**\n   * Should be a valid regular expression, according to the ECMA 262 regular expression dialect.\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.8\n   */\n  pattern(pattern: string | RegExp): this {\n    super.set(\"pattern\", toJsonRegex(pattern));\n\n    return this;\n  }\n\n  /**\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-8\n   */\n  format(format: JsonFormatTypes | ValueOf<JsonFormatTypes>): this {\n    super.set(\"format\", format);\n\n    return this;\n  }\n\n  /**\n   * A single type, or a union of simple types\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.25\n   */\n  type(type: any | JSONSchema6TypeName | JSONSchema6TypeName[]): this {\n    switch (type) {\n      case Map:\n        super.set(\"type\", getJsonType(type));\n        this._target = type;\n        this._isCollection = true;\n        if (!this.has(\"additionalProperties\")) {\n          super.set(\"additionalProperties\", this.itemSchema({}));\n        }\n        break;\n\n      case Array:\n        super.set(\"type\", getJsonType(type));\n        this._target = type;\n        this._isCollection = true;\n\n        if (!this.has(\"items\")) {\n          super.set(\"items\", this.itemSchema({}));\n        }\n        break;\n\n      case Set:\n        super.set(\"type\", getJsonType(type));\n        this._target = type;\n        this._isCollection = true;\n        this.uniqueItems(true);\n\n        if (!this.has(\"items\")) {\n          super.set(\"items\", this.itemSchema({}));\n        }\n        break;\n\n      case \"integer\":\n        super.set(\"type\", getJsonType(type));\n        this.integer();\n        break;\n\n      case Object:\n      case Date:\n      case Boolean:\n      case Number:\n      case String:\n        super.set(\"type\", getJsonType(type));\n        this._target = type;\n        if (!this.has(\"properties\")) {\n          super.set(\"properties\", {});\n        }\n        break;\n\n      default:\n        if (isClass(type) || isFunction(type)) {\n          super.set(\"type\", undefined);\n          this._target = type;\n\n          if (!this.has(\"properties\")) {\n            super.set(\"properties\", {});\n          }\n        } else {\n          const jsonType = getJsonType(type);\n          if (jsonType === \"generic\") {\n            this._isGeneric = true;\n            super.set(\"$ref\", type);\n          } else {\n            super.set(\"type\", jsonType);\n          }\n        }\n    }\n\n    return this;\n  }\n\n  addTypes(...types: any[]) {\n    types = [].concat(this.get(\"type\")).concat(types as never);\n    types = uniq(types).map(getJsonType);\n\n    this.type(types);\n    // @ts-ignore\n    delete this._target;\n  }\n\n  any(...types: any[]) {\n    types = uniq(types.length ? types : [\"integer\", \"number\", \"string\", \"boolean\", \"array\", \"object\", \"null\"]).map(getJsonType);\n\n    this.type(types.length === 1 ? types[0] : types);\n\n    // @ts-ignore\n    delete this._target;\n\n    return this;\n  }\n\n  integer() {\n    super.set(\"type\", \"integer\");\n    super.set(\"multipleOf\", 1.0);\n\n    return this;\n  }\n\n  /**\n   * This attribute is a string that provides a short description of the instance property.\n   *\n   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.2\n   */\n  title(title: string): this {\n    super.set(\"title\", title);\n\n    return this;\n  }\n\n  toObject(options?: JsonSchemaOptions) {\n    return this.toJSON(options);\n  }\n\n  toJSON(options?: JsonSchemaOptions) {\n    let addDef = false;\n\n    if (!options) {\n      addDef = true;\n      options = {schemas: {}};\n    }\n\n    const schema = serializeJsonSchema(this, options);\n\n    if (addDef && options.schemas && Object.keys(options.schemas).length) {\n      schema.definitions = options.schemas;\n    }\n\n    return schema;\n  }\n\n  assign(obj: JsonSchema | Partial<JsonSchemaObject> = {}) {\n    const entries = obj instanceof JsonSchema ? [...obj.entries()] : Object.entries(obj);\n\n    entries.forEach(([key, value]) => {\n      this.set(key, value);\n    });\n\n    if (obj instanceof JsonSchema) {\n      this.$selfRequired = obj.$selfRequired;\n\n      obj.$required.forEach((key) => {\n        this.$required.add(key);\n      });\n\n      this._ref = obj._ref;\n      this._alias = new Map(this._alias.entries());\n      obj._genericLabels && (this._genericLabels = [...obj._genericLabels]);\n      this._nestedGenerics = obj._nestedGenerics.map((item) => [...item]);\n      this._target = obj._target;\n      this._isGeneric = obj._isGeneric;\n      this._isCollection = obj._isCollection;\n      this._ref = obj._ref;\n\n      super.set(\"type\", obj.get(\"type\"));\n    }\n\n    return this;\n  }\n\n  set(key: string, value: any): this {\n    if (key in this) {\n      // @ts-ignore\n      this[key](value);\n    } else {\n      super.set(key, value);\n    }\n\n    return this;\n  }\n\n  /**\n   * Return the itemSchema computed type.\n   * If the type is a function used for recursive model,\n   * the function will be called to get the right type.\n   */\n  getComputedType(): any {\n    return getComputedType(this._target);\n  }\n\n  getComputedItemType(): any {\n    return this._itemSchema ? this._itemSchema.getComputedType() : this.getComputedType();\n  }\n\n  /**\n   * Return the Json type as string\n   */\n  getJsonType(): string {\n    return this.get(\"type\") || getJsonType(this.getComputedType());\n  }\n\n  /**\n   * Get the symbolic name of the entity\n   */\n  getName() {\n    return this.get(\"name\") || (this._target ? nameOf(classOf(this.getComputedType())) : \"\");\n  }\n\n  clone() {\n    return new JsonSchema(this);\n  }\n}\n"]}