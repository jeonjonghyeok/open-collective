import { Type } from "@tsed/core";
import { JsonSchemaObject } from "../../domain";
import { JsonParameterTypes } from "../../domain/JsonParameterTypes";
export interface InChainedDecorators {
    <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>): TypedPropertyDescriptor<T> | void;
    (target: Object, propertyKey: string | symbol, parameterIndex: number): void;
    (target: Function): void;
    /**
     * Type of this in parameter
     * @param type
     */
    Type(type: Type<any>): this;
    /**
     *
     * @param name
     */
    Name(name: string): this;
    /**
     *
     * @param description
     */
    Description(description: string): this;
    /**
     *
     * @param required
     */
    Required(required?: boolean): this;
    /**
     * Add pattern constraint. Only available for OPENAPI.
     * @param pattern
     */
    Pattern(pattern: string | RegExp): this;
    /**
     * Add custom schema.
     * @param schema
     */
    Schema(schema: Partial<JsonSchemaObject>): this;
}
/**
 * Add a input parameter.
 *
 * ::: warning
 * Don't use decorator with Ts.ED application to decorate parameters. Use @@BodyParams@@, @@PathParams@@, etc... instead.
 * But you can use this decorator on Method, to add extra in parameters like Authorization header.
 *
 * ```typescript
 * @Controller("/")
 * class MyController {
 *    @Get("/")
 *    @In("header").Type(String).Name("Authorization").Required()
 *    method() {
 *    }
 *  }
 * ```
 * :::
 *
 * @param inType
 * @decorator
 * @swagger
 * @schema
 * @input
 * @operation
 */
export declare function In(inType: JsonParameterTypes | string): InChainedDecorators;
