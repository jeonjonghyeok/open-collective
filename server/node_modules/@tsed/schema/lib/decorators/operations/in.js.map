{"version":3,"file":"in.js","sourceRoot":"","sources":["../../../src/decorators/operations/in.ts"],"names":[],"mappings":";;;AAAA,qCAA6F;AAC7F,yCAA0F;AA8C1F;;;;;;;;;;;;;;;;;;;;;;;;GAwBG;AACH,SAAgB,EAAE,CAAC,MAAmC;IACpD,MAAM,aAAa,GAAG,IAAI,sBAAa,EAAE,CAAC;IAC1C,MAAM,MAAM,GAAQ,EAAE,CAAC;IAEvB,MAAM,SAAS,GAAG,CAAC,MAAW,EAAE,WAA6B,EAAE,KAAmC,EAAE,EAAE;QACpG,MAAM,KAAK,GAAG,wBAAe,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC;QAE/D,QAAQ,KAAK,CAAC,aAAa,EAAE;YAC3B,KAAK,qBAAc,CAAC,KAAK;gBACvB,KAAK,CAAC,SAAU,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC;gBAC5B,MAAM;YACR,KAAK,qBAAc,CAAC,MAAM;gBACxB,aAAa,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC;gBACzB,KAAK,CAAC,SAAU,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC;gBAEjD,aAAa,CAAC,MAAM,CAAC,mBAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;gBAC9C,MAAM;YAER,KAAK,qBAAc,CAAC,KAAK;gBACvB,wBAAiB,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;gBACrC,MAAM;YAER;gBACE,MAAM,IAAI,+BAAwB,CAAC,EAAE,EAAE,CAAC,MAAM,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC;SACxE;IACH,CAAC,CAAC;IAEF,SAAS,CAAC,IAAI,GAAG,CAAC,IAAe,EAAE,EAAE;QACnC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;QAEnB,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC;IAEF,SAAS,CAAC,IAAI,GAAG,CAAC,IAAY,EAAE,EAAE;QAChC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEzB,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC;IAEF,SAAS,CAAC,WAAW,GAAG,CAAC,WAAmB,EAAE,EAAE;QAC9C,aAAa,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;QAEvC,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC;IAEF,SAAS,CAAC,QAAQ,GAAG,CAAC,WAAoB,IAAI,EAAE,EAAE;QAChD,aAAa,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QAEjC,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC;IAEF,SAAS,CAAC,OAAO,GAAG,CAAC,OAAwB,EAAE,EAAE;QAC/C,OAAO,SAAS,CAAC,MAAM,CAAC,EAAC,OAAO,EAAE,OAAO,CAAC,QAAQ,EAAE,EAAC,CAAC,CAAC;IACzD,CAAC,CAAC;IAEF,SAAS,CAAC,MAAM,GAAG,CAAC,OAAY,EAAE,EAAE;QAClC,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QAE/B,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC;IAEF,OAAO,SAAS,CAAC;AACnB,CAAC;AA9DD,gBA8DC","sourcesContent":["import {decorateMethodsOf, DecoratorTypes, Type, UnsupportedDecoratorType} from \"@tsed/core\";\nimport {JsonEntityStore, JsonParameter, JsonSchema, JsonSchemaObject} from \"../../domain\";\nimport {JsonParameterTypes} from \"../../domain/JsonParameterTypes\";\n\nexport interface InChainedDecorators {\n  <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>): TypedPropertyDescriptor<T> | void;\n\n  (target: Object, propertyKey: string | symbol, parameterIndex: number): void;\n  (target: Function): void;\n\n  /**\n   * Type of this in parameter\n   * @param type\n   */\n  Type(type: Type<any>): this;\n\n  /**\n   *\n   * @param name\n   */\n  Name(name: string): this;\n\n  /**\n   *\n   * @param description\n   */\n  Description(description: string): this;\n\n  /**\n   *\n   * @param required\n   */\n  Required(required?: boolean): this;\n\n  /**\n   * Add pattern constraint. Only available for OPENAPI.\n   * @param pattern\n   */\n  Pattern(pattern: string | RegExp): this;\n\n  /**\n   * Add custom schema.\n   * @param schema\n   */\n  Schema(schema: Partial<JsonSchemaObject>): this;\n}\n\n/**\n * Add a input parameter.\n *\n * ::: warning\n * Don't use decorator with Ts.ED application to decorate parameters. Use @@BodyParams@@, @@PathParams@@, etc... instead.\n * But you can use this decorator on Method, to add extra in parameters like Authorization header.\n *\n * ```typescript\n * @Controller(\"/\")\n * class MyController {\n *    @Get(\"/\")\n *    @In(\"header\").Type(String).Name(\"Authorization\").Required()\n *    method() {\n *    }\n *  }\n * ```\n * :::\n *\n * @param inType\n * @decorator\n * @swagger\n * @schema\n * @input\n * @operation\n */\nexport function In(inType: JsonParameterTypes | string): InChainedDecorators {\n  const jsonParameter = new JsonParameter();\n  const schema: any = {};\n\n  const decorator = (target: any, propertyKey?: string | symbol, index?: PropertyDescriptor | number) => {\n    const store = JsonEntityStore.from(target, propertyKey, index);\n\n    switch (store.decoratorType) {\n      case DecoratorTypes.PARAM:\n        store.parameter!.in(inType);\n        break;\n      case DecoratorTypes.METHOD:\n        jsonParameter.in(inType);\n        store.operation!.addParameter(-1, jsonParameter);\n\n        jsonParameter.schema(JsonSchema.from(schema));\n        break;\n\n      case DecoratorTypes.CLASS:\n        decorateMethodsOf(target, decorator);\n        break;\n\n      default:\n        throw new UnsupportedDecoratorType(In, [target, propertyKey, index]);\n    }\n  };\n\n  decorator.Type = (type: Type<any>) => {\n    schema.type = type;\n\n    return decorator;\n  };\n\n  decorator.Name = (name: string) => {\n    jsonParameter.name(name);\n\n    return decorator;\n  };\n\n  decorator.Description = (description: string) => {\n    jsonParameter.description(description);\n\n    return decorator;\n  };\n\n  decorator.Required = (required: boolean = true) => {\n    jsonParameter.required(required);\n\n    return decorator;\n  };\n\n  decorator.Pattern = (pattern: string | RegExp) => {\n    return decorator.Schema({pattern: pattern.toString()});\n  };\n\n  decorator.Schema = (_schema: any) => {\n    Object.assign(schema, _schema);\n\n    return decorator;\n  };\n\n  return decorator;\n}\n"]}