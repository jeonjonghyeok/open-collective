{"version":3,"file":"status.js","sourceRoot":"","sources":["../../../src/decorators/operations/status.ts"],"names":[],"mappings":";;;AACA,uCAA4D;AAE5D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2HG;AACH,SAAgB,MAAM,CAAC,MAAuB,EAAE,KAAuB;IACrE,OAAO,iBAAO,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;AAChC,CAAC;AAFD,wBAEC","sourcesContent":["import {Type} from \"@tsed/core\";\nimport {Returns, ReturnsChainedDecorators} from \"./returns\";\n\n/**\n * Add responses documentation for a specific status code.\n *\n * ## Usage\n *\n * Ts.ED v6 API introducing the chaining decorator concept.\n * Now a decorator like Returns can be used with another decorators like Description.\n *\n * ```typescript\n * import {Returns} from \"@tsed/schema\";\n *\n * @Controller(\"/\")\n * class MyController {\n *   @Status(404, String).Description(\"Not Found\")\n *   @Status(200, Model).Description(\"Success\")\n *   async myMethod(): Promise<Model> {}\n * }\n * ```\n *\n * ::: tip\n * TypeScript and your IDE will discover automatically the chained decorators. But for more details you can look on @@ReturnsChainedDecorators@@ interface, to know\n * what chained decorators are available under Returns decorator.\n * :::\n *\n * This example will produce this documentation in swagger:\n *\n * ```json\n * {\n *   \"responses\": {\n *     \"404\": {\n *       \"description\": \"Description\",\n *       \"schema\": {\"type\": \"string\"}\n *     },\n *     \"2OO\": {\n *       \"description\": \"Description\",\n *       \"schema\": {\"$ref\": \"...\"}\n *     }\n *   }\n * }\n * ```\n *\n * ### Declaring a generic model\n *\n * Sometime, it might be useful to use generic models. TypeScript doesn't store the generic type in the metadata. This is why we need to\n * declare explicitly the generic models with the decorators.\n *\n * One of the generic's usage, can be a paginated list. With Returns decorator it's now possible to declare generic type and generate the appropriate OpenSpec documentation.\n *\n * Starting with the pagination model, by using @@Generics@@ and @@CollectionOf@@:\n *\n * ```typescript\n * @Generics(\"T\")\n * class Pagination<T> {\n *  @CollectionOf(\"T\")\n *  data: T[];\n *\n *  @Property()\n *  totalCount: number;\n * }\n * ```\n *\n * Now, we need a model to be used with the generic Pagination model:\n *\n * ```typescript\n * class Product {\n *  @Property()\n *  id: string;\n *\n *  @Property()\n *  title: string;\n * }\n * ```\n *\n * Finally, we can use our models on a method as following:\n *\n * ```typescript\n * class Controller {\n *   @OperationPath(\"POST\", \"/\")\n *   @Status(200, Pagination).Of(Product).Description(\"description\")\n *   async method(): Promise<Pagination<Product> | null> {\n *     return null;\n *   }\n * }\n * ```\n *\n * ### Declaring a nested generics models <Badge text=\"6+\"/>\n *\n * It's also possible to declare a nested generics models in order to have this type `Pagination<Submission<Product>>`:\n *\n * ```typescript\n * import {Generics, Property, Returns} from \"@tsed/schema\";\n * import {Post} from \"@tsed/common\";\n *\n * class Controller {\n *   @Post(\"/\")\n *   @Status(200, Pagination).Of(Submission).Nested(Product).Description(\"description\")\n *   async method(): Promise<Pagination<Submission<Product>> | null> {\n *     return null;\n *   }\n * }\n * ```\n *\n * And here is the Submission model:\n *\n * ```typescript\n * import {Generics, Property} from \"@tsed/schema\";\n *\n * @Generics(\"T\")\n * class Submission<T> {\n *   @Property()\n *   _id: string;\n *   @Property(\"T\")\n *   data: T;\n * }\n * ```\n *\n * @param status\n * @param model\n * @decorator\n * @swagger\n * @schema\n * @response\n * @operation\n */\nexport function Status(status: string | number, model?: Type<any> | any): ReturnsChainedDecorators {\n  return Returns(status, model);\n}\n"]}