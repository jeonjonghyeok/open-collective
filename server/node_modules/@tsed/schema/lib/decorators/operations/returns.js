"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Returns = void 0;
const core_1 = require("@tsed/core");
const defineStatusModel_1 = require("../../utils/defineStatusModel");
const httpStatusMessages_1 = require("../../constants/httpStatusMessages");
const JsonEntityStore_1 = require("../../domain/JsonEntityStore");
const JsonResponse_1 = require("../../domain/JsonResponse");
const JsonSchema_1 = require("../../domain/JsonSchema");
const isSuccessStatus_1 = require("../../utils/isSuccessStatus");
const mapHeaders_1 = require("../../utils/mapHeaders");
function getContentType({ contentType, model }) {
    if (model && !core_1.isPlainObject(model) && !core_1.isPrimitiveOrPrimitiveClass(model)) {
        contentType = contentType || "application/json";
    }
    return contentType;
}
function getStatus({ status }) {
    return status || "default";
}
function initSchemaAction(ctx) {
    const { model, response, store, decoratorContext } = ctx;
    const operation = store.operation;
    const currentStatus = getStatus(ctx);
    if (decoratorContext === core_1.DecoratorTypes.CLASS) {
        const current = operation.getResponseOf(currentStatus);
        current.get("description") && response.description(current.get("description"));
        current.get("headers") &&
            response.headers({
                ...(response.get("headers") || {}),
                ...current.get("headers")
            });
    }
    const contentType = getContentType(ctx);
    const currentResponse = operation.addResponse(currentStatus, response).getResponseOf(currentStatus);
    const media = currentResponse.getMedia(contentType || "*/*");
    const schema = media.get("schema") || new JsonSchema_1.JsonSchema({ type: model });
    model && schema.type(model);
    ctx.currentSchema = schema;
    media.schema(schema);
    if (isSuccessStatus_1.isSuccessStatus(ctx.status) || currentStatus === "default") {
        if (model) {
            store.type = model;
        }
    }
    // additional info for OS2
    contentType && operation.addProduce(contentType);
}
function checkPrimitive(model) {
    if (core_1.isPrimitiveOrPrimitiveClass(model)) {
        throw new Error("Returns.Of cannot be used with the following primitive classes: String, Number, Boolean");
    }
}
function checkCollection(model) {
    if (core_1.isCollection(model)) {
        throw new Error("Returns.Nested cannot be used with the following classes: Map, Set, Array, String, Number, Boolean");
    }
}
/**
 * Add responses documentation for a specific status code.
 *
 * ## Usage
 *
 * Ts.ED v5/v6 API introducing the chaining decorator concept. Now a decorator like Returns can be used with another decorators like Description.
 *
 * ::: warning
 * v5 has a basic support of the chaining decorator to facilitate the migration to v6!
 * :::
 *
 * ```typescript
 * import {Returns} from "@tsed/schema";
 *
 * @Controller("/")
 * class MyController {
 *   @Returns(404, String).Description("Not Found")
 *   @Returns(200, Model).Description("Success")
 *   async myMethod(): Promise<Model> {}
 * }
 * ```
 *
 * ::: tip
 * TypeScript and your IDE will discover automatically the chained decorators. But for more details you can look on @@ReturnsChainedDecorators@@ interface, to know
 * what chained decorators are available under Returns decorator.
 * :::
 *
 * This example will produce this documentation in swagger:
 *
 * ```json
 * {
 *   "responses": {
 *     "404": {
 *       "description": "Description",
 *       "schema": {"type": "string"}
 *     },
 *     "2OO": {
 *       "description": "Description",
 *       "schema": {"$ref": "..."}
 *     }
 *   }
 * }
 * ```
 *
 * ## Declaring an Array
 *
 * Use chained decorators to declare an array with model as following:
 *
 * ```typescript
 * import {Returns} from "@tsed/schema";
 *
 * @Controller("/models")
 * class ModelCtrl {
 *   @Get("/")
 *   @Returns(200, Array).Of(Model).Description("Success")
 *   async myMethod(): Promise<Model>  {
 *   }
 * }
 * ```
 *
 * Deprecated version:
 *
 * ```typescript
 * import {ReturnsArray} from "@tsed/common";
 * import {Returns} from "@tsed/schema";
 *
 * @Controller("/")
 * class MyController {
 *   @ReturnsArray(200, Model) // deprecated
 *   async myMethod(): Promise<Model> {}
 * }
 * ```
 *
 * ### Declaring a generic model <Badge text="6+"/>
 *
 * Sometime, it might be useful to use generic models. TypeScript doesn't store the generic type in the metadata. This is why we need to
 * declare explicitly the generic models with the decorators.
 *
 * One of the generic's usage, can be a paginated list. With Returns decorator it's now possible to declare generic type and generate the appropriate OpenSpec documentation.
 *
 * Starting with the pagination model, by using @@Generics@@ and @@CollectionOf@@:
 *
 * ```typescript
 * @Generics("T")
 * class Pagination<T> {
 *  @CollectionOf("T")
 *  data: T[];
 *
 *  @Property()
 *  totalCount: number;
 * }
 * ```
 *
 * Now, we need a model to be used with the generic Pagination model:
 *
 * ```typescript
 * class Product {
 *  @Property()
 *  id: string;
 *
 *  @Property()
 *  title: string;
 * }
 * ```
 *
 * Finally, we can use our models on a method as following:
 *
 * ```typescript
 * class Controller {
 *   @OperationPath("POST", "/")
 *   @Returns(200, Pagination).Of(Product).Description("description")
 *   async method(): Promise<Pagination<Product> | null> {
 *     return null;
 *   }
 * }
 * ```
 *
 * ### Declaring a nested generics models <Badge text="6+"/>
 *
 * It's also possible to declare a nested generics models in order to have this type `Pagination<Submission<Product>>`:
 *
 * ```typescript
 * import {Generics, Property, Returns} from "@tsed/schema";
 * import {Post} from "@tsed/common";
 *
 * class Controller {
 *   @Post("/")
 *   @Returns(200, Pagination).Of(Submission).Nested(Product).Description("description")
 *   async method(): Promise<Pagination<Submission<Product>> | null> {
 *     return null;
 *   }
 * }
 * ```
 *
 * And here is the Submission model:
 *
 * ```typescript
 * import {Generics, Property} from "@tsed/schema";
 *
 * @Generics("T")
 * class Submission<T> {
 *   @Property()
 *   _id: string;
 *   @Property("T")
 *   data: T;
 * }
 * ```
 *
 * @param status
 * @param model
 * @decorator
 * @swagger
 * @schema
 * @response
 * @operation
 */
function Returns(status, model) {
    const response = new JsonResponse_1.JsonResponse();
    let decoratorContext;
    let contentType;
    if (status && httpStatusMessages_1.HTTP_STATUS_MESSAGES[status]) {
        response.description(httpStatusMessages_1.HTTP_STATUS_MESSAGES[status]);
        if (!model) {
            model = defineStatusModel_1.getStatusModel(+status);
        }
    }
    const actions = [initSchemaAction];
    const decorator = (...args) => {
        const type = core_1.getDecoratorType(args, true);
        switch (type) {
            case core_1.DecoratorTypes.METHOD:
                const store = JsonEntityStore_1.JsonEntityStore.from(...args);
                if (store.operation) {
                    const ctx = { status, contentType, response, model, store, decoratorContext };
                    actions.forEach((action) => {
                        action(ctx);
                    });
                }
                break;
            case core_1.DecoratorTypes.CLASS:
                decoratorContext = core_1.DecoratorTypes.CLASS;
                core_1.decorateMethodsOf(args[0], decorator);
                break;
            default:
                throw new core_1.UnsupportedDecoratorType(Returns, args);
        }
    };
    decorator.Headers = (headers) => {
        response.headers({
            ...(response.get("headers") || {}),
            ...mapHeaders_1.mapHeaders(headers)
        });
        return decorator;
    };
    decorator.Header = (key, value) => {
        decorator.Headers({
            [key]: value
        });
        return decorator;
    };
    decorator.ContentType = (value) => {
        contentType = value;
        return decorator;
    };
    decorator.Description = (description) => {
        response.description(description);
        return decorator;
    };
    decorator.Examples = (examples) => {
        response.set("examples", core_1.isString(examples) ? [examples] : examples);
        return decorator;
    };
    decorator.Type = (type) => {
        model = type;
        return decorator;
    };
    decorator.Of = (...types) => {
        checkPrimitive(model);
        actions.push((ctx) => {
            const { currentSchema } = ctx;
            if (core_1.isCollection(model)) {
                currentSchema === null || currentSchema === void 0 ? void 0 : currentSchema.itemSchema({ type: types[0] });
            }
            else {
                currentSchema === null || currentSchema === void 0 ? void 0 : currentSchema.nestedGenerics.push(types);
            }
        });
        return decorator;
    };
    decorator.Nested = (...generics) => {
        checkPrimitive(model);
        checkCollection(model);
        actions.push((ctx) => {
            const { currentSchema } = ctx;
            currentSchema.nestedGenerics.push(generics);
        });
        return decorator;
    };
    decorator.Schema = (schema) => {
        actions.push((ctx) => {
            const { currentSchema } = ctx;
            currentSchema.assign(schema);
        });
        return decorator;
    };
    decorator.Title = (title) => {
        return decorator.Schema({ title });
    };
    decorator.Status = (code) => {
        status = code;
        return decorator;
    };
    return decorator;
}
exports.Returns = Returns;
//# sourceMappingURL=returns.js.map