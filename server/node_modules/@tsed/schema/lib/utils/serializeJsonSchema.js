"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeJsonSchema = exports.serializeGenerics = exports.serializeAny = exports.serializeObject = exports.serializeMap = exports.serializeInherited = exports.serializeItem = exports.serializeClass = void 0;
const core_1 = require("@tsed/core");
const JsonAliasMap_1 = require("../domain/JsonAliasMap");
const SpecTypes_1 = require("../domain/SpecTypes");
const ignoreHook_1 = require("../hooks/ignoreHook");
const generics_1 = require("./generics");
const getInheritedStores_1 = require("./getInheritedStores");
const getJsonEntityStore_1 = require("./getJsonEntityStore");
const getRequiredProperties_1 = require("./getRequiredProperties");
/**
 * @ignore
 */
const IGNORES = ["name", "$required", "$hooks", "_nestedGenerics"];
/**
 * @ignore
 */
const IGNORES_OPENSPEC = ["const"];
/**
 * @ignore
 */
function isEmptyProperties(key, value) {
    return typeof value === "object" && ["items", "properties", "additionalProperties"].includes(key) && Object.keys(value).length === 0;
}
/**
 * @ignore
 */
function shouldMapAlias(key, value, useAlias) {
    return typeof value === "object" && useAlias && ["properties", "additionalProperties"].includes(key);
}
/**
 * @ignore
 */
function createRef(name, options) {
    const host = getHost(options);
    return {
        $ref: `${host}/${name}`
    };
}
/**
 * @ignore
 */
function serializeClass(value, options = {}) {
    const store = getJsonEntityStore_1.getJsonEntityStore(value.class);
    const name = store.schema.getName() || value.getName();
    if (value.hasGenerics) {
        // Inline generic
        const { type, properties, additionalProperties, items, ...props } = value.toJSON(options);
        const schema = {
            ...serializeAny(store.schema, {
                ...options,
                ...generics_1.popGenerics(value),
                root: false
            }),
            ...props
        };
        if (schema.title) {
            const { title } = schema;
            options.schemas[title] = schema;
            delete schema.title;
            return createRef(title, options);
        }
        return schema;
    }
    if (options.schemas && !options.schemas[name]) {
        options.schemas[name] = {}; // avoid infinite calls
        options.schemas[name] = serializeAny(store.schema, generics_1.mapGenericsOptions({
            ...options,
            root: false
        }));
    }
    return createRef(name, options);
}
exports.serializeClass = serializeClass;
/**
 * ignore
 * @param options
 */
function getHost(options) {
    const { host = `#/${options.specType === "openapi3" ? "components/schemas" : "definitions"}` } = options;
    return host;
}
function toRef(value, schema, options) {
    const name = value.getName();
    options.schemas[value.getName()] = schema;
    return createRef(name, options);
}
/**
 * @ignore
 */
function serializeItem(value, options) {
    return value && value.isClass ? serializeClass(value, options) : serializeAny(value, options);
}
exports.serializeItem = serializeItem;
/**
 * @ignore
 */
function serializeInherited(obj, target, options = {}) {
    const stores = Array.from(getInheritedStores_1.getInheritedStores(target).entries()).filter(([model]) => core_1.classOf(model) !== core_1.classOf(target));
    if (stores.length) {
        const schema = stores.reduce((obj, [, store]) => {
            return core_1.deepExtends(obj, serializeJsonSchema(store.schema, options));
        }, {});
        obj = core_1.deepExtends(schema, obj);
    }
    return obj;
}
exports.serializeInherited = serializeInherited;
/**
 * Serialize class which inherit from Map like JsonMap, JsonOperation, JsonParameter.
 * @param input
 * @param options
 * @ignore
 */
function serializeMap(input, options = {}) {
    options = generics_1.mapGenericsOptions(options);
    return Array.from(input.entries()).reduce((obj, [key, value]) => {
        obj[key] = serializeItem(value, options);
        return obj;
    }, {});
}
exports.serializeMap = serializeMap;
/**
 * Serialize Any object to a json schema
 * @param input
 * @param options
 * @ignore
 */
function serializeObject(input, options) {
    return Object.entries(input).reduce((obj, [key, value]) => {
        if (!ignoreHook_1.alterIgnore(value, options)) {
            obj[key] = serializeItem(value, options);
        }
        return obj;
    }, core_1.isArray(input) ? [] : {});
}
exports.serializeObject = serializeObject;
/**
 * @ignore
 */
function serializeAny(input, options = {}) {
    options.schemas = options.schemas || {};
    if (typeof input !== "object" || input === null) {
        return input;
    }
    if ("toJSON" in input) {
        const schema = input.toJSON(generics_1.mapGenericsOptions(options));
        return input.canRef ? toRef(input, schema, options) : schema;
    }
    return serializeObject(input, options);
}
exports.serializeAny = serializeAny;
/**
 * @ignore
 */
function serializeGenerics(obj, options) {
    const { generics } = options;
    if (generics && obj.$ref) {
        if (generics.has(obj.$ref)) {
            const model = {
                class: generics.get(obj.$ref)
            };
            if (options.nestedGenerics.length === 0) {
                return serializeClass(model, {
                    ...options,
                    generics: undefined
                });
            }
            const store = getJsonEntityStore_1.getJsonEntityStore(model.class);
            return serializeJsonSchema(store.schema, {
                ...options,
                ...generics_1.popGenerics(options),
                root: false
            });
        }
    }
    return obj;
}
exports.serializeGenerics = serializeGenerics;
function shouldSkipKey(key, { specType = SpecTypes_1.SpecTypes.JSON }) {
    return IGNORES.includes(key) || (specType !== SpecTypes_1.SpecTypes.JSON && IGNORES_OPENSPEC.includes(key));
}
/**
 * Convert JsonSchema instance to plain json object
 * @param schema
 * @param options
 * @ignore
 */
function serializeJsonSchema(schema, options = {}) {
    const { useAlias = true, schemas = {}, genericTypes } = options;
    let obj = [...schema.entries()].reduce((item, [key, value]) => {
        if (shouldSkipKey(key, options)) {
            return item;
        }
        if (key === "type") {
            value = schema.getJsonType();
        }
        if (key === "examples" && core_1.isObject(value) && [SpecTypes_1.SpecTypes.OPENAPI, SpecTypes_1.SpecTypes.SWAGGER].includes(options.specType)) {
            key = "example";
            value = Object.values(value)[0];
        }
        if (value) {
            if (value.isClass) {
                value = serializeClass(value, {
                    ...options,
                    useAlias,
                    schemas
                });
            }
            else {
                value = serializeAny(value, {
                    ...options,
                    useAlias,
                    schemas,
                    genericTypes,
                    genericLabels: schema.genericLabels
                });
            }
        }
        if (isEmptyProperties(key, value)) {
            return item;
        }
        if (shouldMapAlias(key, value, useAlias)) {
            value = JsonAliasMap_1.mapAliasedProperties(value, schema.alias);
        }
        item[key] = value;
        return item;
    }, {});
    if (schema.isClass) {
        obj = serializeInherited(obj, schema.getComputedType(), { ...options, root: false, schemas });
    }
    obj = serializeGenerics(obj, { ...options, root: false, schemas });
    obj = getRequiredProperties_1.getRequiredProperties(obj, schema, useAlias);
    return obj;
}
exports.serializeJsonSchema = serializeJsonSchema;
//# sourceMappingURL=serializeJsonSchema.js.map